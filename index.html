<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="RookieGuy Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="RookieGuy Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RookieGuy Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>RookieGuy Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/justOneRookie"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RookieGuy Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">for better myself</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/java_learn_IOmodel_20190227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/java_learn_IOmodel_20190227/" itemprop="url">Java学习日记（二）：Java 网络IO模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T00:00:00+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考自<a href="https://blog.csdn.net/szxiaohe/article/details/81542605" target="_blank" rel="noopener">CSDN Simon格子的博文</a>。</p>
<p>这里本文杜撰了一个大嘴开饭店的故事，来类比Java IO模型的演变，帮助理解几种模型的功能和特点，IO分为磁盘IO和网络IO，本文讨论的都是网络IO。</p>
<p>爪哇村的大嘴做得一手好菜，原本是和平饭店的厨子，对吃的东西悟性很高，工作之余喜欢研究各种创新菜，最近自创一道麻辣小龙虾，顾客们吃后反响强烈，于是，大嘴想自立门户，专门开店经营小龙虾。</p>
<p>说干就干，为了方便抓虾，大嘴将饭店开在了河边，并取名“河底捞”。大嘴虽然姓大，但是野心其实并不大，起初，只是想采取日式料理的做法，店里就他自己一个人，晚上抓虾，白天做成麻辣小龙虾，服务客人。</p>
<p>计划赶不上变化，饭店开张没几天，来吃小龙虾的人越来越多，到饭点时间，大嘴一个人根本忙不过来，实在没办法，于是大嘴找到隔壁张三、李四和王五的老婆，对这3个人讲，到饭点时到他店里来帮忙，主要是帮他当服务员，负责给客人点餐，上菜，结账，清理桌子。大嘴说，来了客人，我就叫你们仨，服务完客人，你们各回各家。于是，我们的BIO通信模型登场了：</p>
<p><img src="/images/java_io_model/BIO.png" alt></p>
<p>来一个客人（Web Brower1），大嘴（Acceptor）就去隔壁叫张三（New Thread1），服务完客人，张三就回家。</p>
<p>来两个客人（Web Brower2），大嘴就去隔壁叫李四（New Thread2），服务完客人，李四就回家。</p>
<p>来三个客人（Web Brower3），大嘴就去隔壁叫王五的老婆（New Thread3），服务完客人，王五的老婆就回家。</p>
<p>经营理念就是<strong>一个服务员全程服务好一个客人（connection per thread）</strong>，客人上桌后，服务员就要站在旁边服务，直到客人用餐完毕。美味的小龙虾和良好的用餐体验，吸引越来越多的村民来大嘴店里用餐。随着客户端数量不断增加，BIO通信模型的问题显露无疑：<strong>每一个新客户端接入时，服务端必须创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接，在高性能服务领域，需要面对成千上万个客户端并发连接，这种模型无法满足高性能、高并发接入场景。</strong>采用这种模型，要想满足客人用餐需求，再多来一个客人，大嘴得临时叫上赵六，孙七，周八，吴九，郑十，大嘴能叫过来帮忙的邻居就这么几位，叫完就没有了。后面来的客人，大嘴只好让他们回家，改天再来。</p>
<p>这样下去显然不行，大嘴又找到隔壁张三、李四和王五的老婆，对这3个人讲：以后我不叫你们了，你们每天直接来我店里上班，换上“河底捞”的统一服装，朝九晚五，我给你们开固定工资，这样就节省了你们来来回回的时间，一开始张三和李四不是特别愿意，说要在家陪老婆，但是很快被王五的老婆说服了。<strong>于是有了采用线程池和任务队列的“伪异步IO模型”。</strong></p>
<p><strong>当有新客户端接入时，将客户端的Socket封装成一个Task，投递到后端线程池中进行处理，线程池维护一个消息队列和N个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，资源是可控的，无论多少个客户端并发访问，也不会导致资源耗尽和宕机。</strong></p>
<p><img src="/images/java_io_model/fake_io.png" alt></p>
<p>没客人时，张三、李四和王五的老婆都在店里待命，新来了客人，他们仨陆续上去服务，服务完，继续在店里待命，店门口放了5个凳子，供客人等候。这样改进之后，用户体验有了一定提升，但3个服务员在客人用餐时，还是全程陪在桌旁为其服务，用过餐的都夸“河底捞”的服务好。尤其是钱大爷，特别满意“河底捞”的服务，钱大爷爱喝酒，每次用餐要4个小时，王五的老婆在旁边一会上菜，一会倒酒，一会递热毛巾，基本上一天就服务钱大爷这一个客人。当钱大爷这类人来用餐时，外面排队的5个凳子早早就坐满了人，并且后面再来的客人，大嘴只能劝他们改日再来。</p>
<p>这就是这种“伪异步IO模型”典型的问题，<strong>当可用线程都被故障服务器阻塞时，后续所有的IO消息都将在队列中排队，线程池采用阻塞队列实现，当队列积满后，后续入队的操作将被阻塞，<em>前端只有一个Accept线程接收客户端接入，它被阻塞在线程池的同步阻塞队列之后，新的客户端请求将被拒绝，客户端会发生大量连接超时</em>。</strong></p>
<p>大嘴很快意识到，“伪异步IO模型”依然极大地限制了客流量，导致后面来的客人怨声载道，村里的林捕头每天下班过来，想要吃一顿小龙虾，发现门口已经排满了人，根本吃不上。林捕头放出风声，说大嘴长期在河边抓虾，可能会破坏村里的生态环境。于是大嘴紧急召集张三、李四和王五的老婆开会，讨论如何让林捕头能够排上队，吃上小龙虾。</p>
<p>张三曾经在爪哇村村委会干过一段时间码农，他说他知道有一种<strong>NIO模型（非阻塞IO）</strong>，和现在店里的情况很像。几乎所有的网络连接都会经过<strong>“读取请求内容—&gt;解码—&gt;计算处理—&gt;编码—&gt;回复”</strong>，类似于店里<strong>“接待—&gt;找桌—&gt;点菜—&gt;上菜—&gt;结账—&gt;收拾桌子”，每开一个桌子，我们称为开了一个channel，每个桌上放一个灯，当客人有点菜、上菜、结账等服务需求时，点亮灯，我们会有一个全局的管理者selector，会不断地在各个channel轮询（polling），检测是否有灯点亮，如果有灯亮，则通知专门的服务员来进行服务。这就是IO多路复用，IO多路复用可同时监听多个描述符（socket），一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，<em>IO多路复用避免阻塞在IO上，原本为多线程来接收多个连接的消息变为单线程保存多个socket的状态后轮询处理</em>。</strong></p>
<p><strong>这种机制也叫做反应器模式（Reactor），Reactor负责响应IO事件（accept，read，send），当检测到一个新的事件，将其发送给相应的Handler去处理。Reactor为单个线程，需要处理accept连接，同时发送请求到Handler中。由于只有单个线程，所以Handler中的业务需要能够快速处理完。</strong></p>
<p><img src="/images/java_io_model/reactor.png" alt></p>
<p>于是，大嘴安排张三专职点菜传菜，李四负责上菜结账，王五的老婆负责其他on call的特殊服务，大嘴则负责盯着各个桌上的灯是否亮着，有灯点亮就叫相应的服务员过来处理。这样改进后，效果显著，虽然饭店已经人满为患，门口竟然没有排队的，生意越来越红火。</p>
<p>改进流程后，服务效率显著提高，店里的客流量继续增长，三个服务员每天忙得不可开交，但对于来个十桌八桌客人，三个服务员基本可以轻松应付。不过在某些情况下，会突然出现人手急剧短缺的情况，这种情况在林捕头就餐时经常发生。林捕头有选择困难症，每次点菜时，要考虑半个小时，并且不让服务员离开，因为他有很多问题向服务员咨询。结账时，因为要拿去衙门报销，需要开发票，又需要服务员帮忙写发票抬头，打印，最后还不忘找服务员要停车票。</p>
<p><strong>这个问题正好就是NIO模型的缺点，这种模型由于IO在阻塞时会一直等待，因此在用户负载增加时，性能下降的非常快。server导致阻塞的原因有：</strong></p>
<p><strong>1、serversocket的accept方法，阻塞等待client连接，直到client连接成功。</strong></p>
<p><strong>2、线程从socket inputstream读入数据，会进入阻塞状态，直到全部数据读完。</strong></p>
<p><strong>3、线程向socket outputstream写入数据，会阻塞直到全部数据写完</strong></p>
<p>既然能发现缺点，就有相应的解决办法，聊过非阻塞IO后， 再来看看异步IO（AIO）。 IO方面的概念很多，阻塞性与异步性是其关键概念。简单而言，<strong>凡是需要由应用程序将数据读写到应用程序内存中的IO，都是同步IO，比如上面的BIO与NIO。相对的，凡是由OS来完成读写的，就是异步IO。</strong>这个说法有些迷惑，举例而言，<strong>在NIO中，当应用程序检测到某个Channel有可读数据时，必须显式发起一个read请求。而在异步IO中，应用程序仅仅需要告诉OS，我需要什么数据，并提供给OS一个Buffer和一个回调。OS会自己检测Channel的可读性，当发现其可读，会自动将数据复制到Buffer中，并通知应用程序任务完成。</strong>异步IO的典型实现是NodeJS。显然，由于将任务进一步下发到了OS，应用程序的可伸缩性及性能会大大增强。并且，比起非阻塞的NIO，异步IO编程更加容易一些, 性能也基本上总是优于它。</p>
<p>有了这一理论基础，可以继续讲大嘴的故事。</p>
<p>不到一年，小龙虾生意一发不可收拾，店里的营收越来越可观，王五的老婆也用上了iPhoneX和ipad pro，但王五的老婆一直想买一辆BMW，在得知ipad里面有很多点餐的APP后，她对大嘴说：其实咱们店只需要一个服务员就可以了，张三和李四完全是多余的，把他们俩的钱给我，我一个人可以服务所有客人。大嘴表示怀疑：咱们店一天接待几十桌客人，你一个人怎么忙得过来？</p>
<p>王五的老婆说，咱们店里所有的工作分为两类：</p>
<p>1.马上就能干完的，例如接待，找座，下单，清理桌子等</p>
<p>2.需要等别人干完才能干的活，比如点菜（需要顾客想好吃什么），上菜（需要后厨做好），结账（需要顾客确认账单、买单）等。</p>
<p>对于第1类工作，我马上干活，对于第2类工作，我也不会等待，我只要告诉别人，你弄完了告诉我一声，我会接着干，然后马上去做第1类工作。比如点菜，我只要给客人一个ipad，给完ipad我就立刻离开，客人点完餐后叫我，我只要点确认下单即可。结账时，我只要给客人一张带二维码的消费清单小票，我就立刻离开，客人确认完消费清单，自己扫描二维码进行支付，结账完毕后，叫我过来确认即可，我顺便把桌子打扫了，如果顾客需要发票，可以去前台凭小票自助打印，不需要服务员参与。</p>
<p>王五的老婆说的这一套，正是jdk7引入的NIO2模型，又叫异步IO（AIO）。为了说明异步IO，用计算机视角再回顾一下店里的服务流程：</p>
<p><strong>服务员：线程</strong></p>
<p><strong>顾客：http请求</strong></p>
<p><strong>后厨做菜，客人吃饭：耗时的IO操作</strong></p>
<p><strong>后厨大喊一声上菜：这是一个长时间IO操作完成后所发出的事件</strong></p>
<p><strong>客人说结账：另外一个长时间IO操作完成后所发出的事件</strong></p>
<p>第一类工作(迎客，找座，下单) : 在服务器端的业务逻辑代码，能够快速执行。</p>
<p>第二类工作(上菜，结账) : 同样是能快速执行的代码，但是他们需要等待那些耗时的IO 操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在AIO中实际上是在回调函数中来执行的：</p>
<p>下面是AIO服务模式的伪代码：</p>
<p><img src="/images/java_io_model/AIO.png" alt></p>
<p>后厨处理（）这个函数接受两个参数，一个是事件名，另外一个是匿名的回调函数，事件发生，回调函数才会执行。客人吃饭（）函数也是类似。</p>
<p>王五的老婆接着说，我的秘诀就是不等待，耗时的操作全部使用异步方式，别人做完了再通知我。大嘴听了目瞪口呆，原来饭店可以这样开，一旦拥有这种服务效率，明年利润再翻一番不是问题，后年可以赴港交所上市了。</p>
<p>总结上述几种IO模型，将其功能和特性进行对比：</p>
<p><img src="/images/java_io_model/IOtable.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/sort_20190227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/sort_20190227/" itemprop="url">常用的一些简单排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T00:00:00+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思想：从某个方向两两相邻比较元素的值，若为逆序，则交换。每一轮冒泡完可以保证在第i个位置的元素是正确的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasSwap = <span class="keyword">false</span>; <span class="comment">//判断是否进行过交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;   </span><br><span class="line">             <span class="keyword">if</span>(a[j]&gt;a[j-<span class="number">1</span>])&#123;</span><br><span class="line">            	swap(a[j], a[j-<span class="number">1</span>]);</span><br><span class="line">            	hasSwap = <span class="keyword">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasSwap) <span class="keyword">break</span>;  <span class="comment">//如果一次交换都没有，则表示已经有序，直接结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>思想：依次将待排序的目标插入到已经排好序的序列里，直到所有的序列都排好序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i-<span class="number">1</span>]&lt;a[i])&#123;  <span class="comment">//如果待排元素比已排最小元素大，则需要进行排序</span></span><br><span class="line">            <span class="keyword">int</span> temp=a[i];  <span class="comment">//保存待排元素</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            	<span class="keyword">if</span>(a[j]&lt;temp)   <span class="comment">//如果这个位置比待排元素小，后移</span></span><br><span class="line">                    a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>；<span class="comment">//否则，表示找到了位置。</span></span><br><span class="line">        	&#125;</span><br><span class="line">            a[j+<span class="number">1</span>]=temp;<span class="comment">//插入到找到的合适的位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>思路：从无序区选择一个最大/最小的元素插入到有序区的最后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&gt;a[max])</span><br><span class="line">                max=j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i],a[max]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>思想：让序列基本有序，使用<strong>分组插入排序</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,gap,k;</span><br><span class="line">    <span class="keyword">for</span>(gap=len/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)&#123;  <span class="comment">//确定步长</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;gap;i++)&#123;  <span class="comment">//确定分组个数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(j=i+gap;j&lt;len;j=j+gap)&#123; <span class="comment">//对每个分组进行插入排序</span></span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;a[j-gap])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                    <span class="keyword">for</span>(k=j-gap;k&gt;=<span class="number">0</span>;k=k-gap)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(a[k]&lt;temp) a[k+gap]=a[k];</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k+gap]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>思想：分治法，将数组拆分为n个组排序，然后归并。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end, <span class="keyword">int</span> temp[])</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/java_interview_20190227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/java_interview_20190227/" itemprop="url">Java面试小题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T00:00:00+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里记录一下Java面试的一些小题目，随心记录。</p>
<ul>
<li><p>java中，equals()和==的区别</p>
<blockquote>
<p>值类型是存储在内存中的堆栈（以后简称栈），而引用类型的变量在<strong>栈中仅仅是存储引用类型变量的地址</strong>，而其<strong>本身则存储在堆中</strong>。</p>
<p>==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量本身在<strong>堆中的地址</strong>是否相同，即<strong>栈中的内容</strong>是否相同（是否保存了同一个地址）。</p>
<p>​    equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。</p>
<p>​    ==比较的是2个对象的地址，而equals比较的是2个对象的内容。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>sleep()和wait()的区别</p>
<blockquote>
<p>sleep()是属于Thread类的。而wait()是Object类的。</p>
<p>sleep的线程不会施放对象锁，sleep导致了程序暂停执行，指定了时间，让出cpu，但是其监控状态仍然保持，到了指定的时间会恢复执行。</p>
<p>而wait()调用时会放弃对象锁，进入等待该对象的等待锁定池，只有针对该对象调用notify()方法后本线程才进入等待对象池等待。</p>
</blockquote>
</li>
</ul>
<p>主要看<a href="https://blog.csdn.net/u012073449/article/details/50986250" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: 阿里JAVA开发面试常问问题总结1</a></p>
<p><a href="https://blog.csdn.net/u012073449/article/details/50986782" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: 阿里JAVA开发面试常问问题总结2</a></p>
<p><a href="https://blog.csdn.net/u012073449/article/details/50990546" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: 阿里JAVA开发面试常问问题总结3</a></p>
<p><a href="https://blog.csdn.net/u012073449/article/details/50992348" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: 阿里JAVA开发面试常问问题总结4</a></p>
<p><a href="https://blog.csdn.net/u012073449/article/details/50975024" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: Java中几个“区别”总结</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/redis_learn_1_20190226/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/redis_learn_1_20190226/" itemprop="url">Redis学习日记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T00:00:00+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis学习日记（一）"><a href="#Redis学习日记（一）" class="headerlink" title="Redis学习日记（一）"></a>Redis学习日记（一）</h1><p>首先，<strong>什么是redis</strong>？</p>
<p>Redis 是一个使用<code>ANSI C</code> 编写的开源、支持网络协议、基于内存、可选持久性的键值对数据库,它是一个<code>NOSQL</code>not only sql)数据库,也就是常说的非关系型数据库。</p>
<blockquote>
<p>Nosql的全称是Not Only Sql，指的是非关系型数据库，而我们常用的都是关系型数据库。就像我们常用的mysql，sqlserver一样，这些数据库一般用来存储重要信息，应对普通的业务是没有问题的。但是，随着互联网的高速发展，传统的关系型数据库在应付超大规模，超大流量以及高并发的时候力不从心。而就在这个时候，Nosql得到的高速的发展。下面是对比：</p>
<ul>
<li>存储方式：关系型数据库是表格式的，因此存储在表的行和列中。他们之间很容易关联协作存储，提取数据很方便。而Nosql数据库则与其相反，他是大块的组合在一起。通常存储在数据集中，就像文档、键值对或者图结构。</li>
<li>存储结构：关系型数据库对应的是结构化数据，数据表都预先定义了结构（列的定义），结构描述了数据的形式和内容。这一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难。而Nosql数据库基于动态结构，使用与非结构化数据。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构的变化。</li>
<li>存储扩展：这可能是两者之间最大的区别，关系型数据库是纵向扩展，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能涉及到多个表，需要通过提升计算机性能来克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限。而Nosql数据库是横向扩展的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。</li>
</ul>
</blockquote>
<h2 id="Redis-应用场景"><a href="#Redis-应用场景" class="headerlink" title="Redis 应用场景"></a>Redis 应用场景</h2><p>主要用于数据量大，并发量高的情况下</p>
<ul>
<li>数据缓存（页面具体数据），页面缓存（商品内容，新闻内容）</li>
<li>分布式集群中架构中的Session分离</li>
<li>应用排行榜，在线好友列表等</li>
<li>任务队列，例如抢购秒杀等</li>
<li>显示最新的项目列表(用户最新的回复，评论等)</li>
<li>需要负载均衡的场景（主从同步）</li>
</ul>
<blockquote>
<p>Redis在很多方面与其他数据库解决方案不同：它<strong>使用内存提供主存储支持，而仅使用硬盘做持久性的存储</strong>；它的数据模型非常独特，用的是<strong>单线程</strong>。另一个大区别在于，你可以在开发环境中使用Redis的功能，但却不需要转到Redis。</p>
<p>转向Redis当然也是可取的，许多开发者从一开始就把Redis作为首选数据库；但设想如果你的开发环境已经搭建好，应用已经在上面运行了，那么更换数据库框架显然不那么容易。另外在一些需要大容量数据集的应用，Redis也并不适合，因为它的数据集不会超过系统可用的内存。所以如果你有大数据应用，而且主要是读取访问模式，那么Redis并不是正确的选择。</p>
<p><em>你可以把它融入到你的系统中来，这就能够解决很多问题，比如那些你现有的数据库处理起来感到缓慢的任务。这些你就可以通过Redis来进行优化，或者为应用创建些新的功能。</em></p>
</blockquote>
<h2 id="Redis数据类型简介"><a href="#Redis数据类型简介" class="headerlink" title="Redis数据类型简介"></a>Redis数据类型简介</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>存储的值</th>
<th>读写能力</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串，整数或浮点数。可以包含任意数据，包括图片等二进制或者序列化的对象等。单个 <code>value</code> 的值最大上限为 <code>1G</code>字节。</td>
<td>对字符串或一部分字符串执行操作；对整数进行自增和自减操作等</td>
<td>可用于保存图片，商品序列号等。</td>
</tr>
<tr>
<td>Hash</td>
<td>包含键值对的无序散列表。等价于Java 中的 HashMap。但是在 redis 中 hash 的 key 必须是 string 类型。在 Reids 中，每个 Hash 可以存储多达 4 亿个键值对。</td>
<td>对单个 元素进行增、删、改；获取所以的键值对等</td>
<td>保存大量的对象数据</td>
</tr>
<tr>
<td>List</td>
<td>链表上的节点字符串元素。在 Redis 中的 List 类型，其内部使用的是<code>双向链表</code>实现的。</td>
<td>推入、弹出元素；修剪、查找、移除元素等</td>
<td>商品，博客，文章下面的评论列表等。</td>
</tr>
<tr>
<td>Set</td>
<td>各不相同的字符串元素。redis 中的 set 类型和 java 中的 HashSet 类似，其底层都是用HashMap 实现的，只不过所有的 value 都指向同一个对象。</td>
<td>对单个 元素进行增、删、改；计算集合 交，并补集等</td>
<td>对象属性</td>
</tr>
<tr>
<td>Sorted Set</td>
<td>带分数（权重）的有序集合</td>
<td>对单个 元素进行增、删、改；按照分数范围查元素等</td>
<td>商品销售，软件下载等各种排行榜</td>
</tr>
<tr>
<td>HyerLogLog</td>
<td>基数</td>
<td>对输入元素不进行存储，、只存储基数。</td>
<td>基数统计</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>Pub/Sub</strong>：Pub/Sub 从字面上理解就是<strong>发布（Publish）与订阅（Subscribe）</strong>，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</li>
</ul>
</blockquote>
<h2 id="主从同步（复制）"><a href="#主从同步（复制）" class="headerlink" title="主从同步（复制）"></a>主从同步（复制）</h2><p>Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态；</li>
<li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p>
<p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送SYNC命令；</li>
<li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令；</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器<strong>执行BGSAVE命令时的数据库状态</strong>。</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，<strong>从服务器执行这些写命令</strong>，将自己的数据库状态更新至主服务器数据库当前所处的状态。</li>
</ol>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>在执行完同步操作之后，主从服务器之间数据库状态已经相同了。但这个状态并非一成不变，如果主服务器执行了写操作，那么主服务器的数据库状态就会修改，并导致主从服务器状态不再一致。</p>
<p>所以为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis提供了两种持久化：<strong>快照snapshotting</strong>和<strong>AOF（append-only file）</strong>。</p>
<h3 id="快照Snapshotting"><a href="#快照Snapshotting" class="headerlink" title="快照Snapshotting"></a>快照Snapshotting</h3><p>快照持久化方法是 Redis 默认开启的持久化方法，Redis 将某一时刻的快照保存成一种称为 RDB 格式的文件中。RDB 文件是一个经过压缩的二进制文件，通过该文件，Redis 可以将内存中的数据恢复成某一时刻的状态。</p>
<p>Redis 提供了两个命令用来生成 RDB 文件，一个是 SAVE，一个是 BGSAVE。</p>
<ul>
<li>SAVE 命令会阻塞 Redis 服务器进程，走到 RDB 文件创建完毕为止，在 Redis 服务器进程阻塞期间，Redis 不能处理任何命令请求。在生产环境，我们一般不会直接使用 SAVE 命令，原因是由于它会阻塞 Redis 进程。但是，如果机器已没有足够的内存去执行 BGSAVE 命令，或者即使等待持久化操作完毕也无所谓，我们也可以使用 SAVE 命令来生成 RDB 文件。</li>
<li>BGSAVE 命令会派生出一个子进程，然后由子进程创建 RDB 文件，因此，BGSAVE 命令不会阻塞 Redis 服务器进程。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>与快照持久化通过直接保存 Redis 的键值对数据不同，AOF 持久化是通过保存 Redis 执行的写命令来记录 Redis 的内存数据。</p>
<p>理论上说，只要我们保存了所有可能修改 Redis 内存数据的命令（也就是写命令），那么根据这些保存的写命令，我们可以重新恢复 Redis 的内存状态。AOF 持久化正是利用这个原理来实现数据的持久化与数据的恢复的。 </p>
<blockquote>
<p><strong>AOF 的优点</strong></p>
<ul>
<li>AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。</li>
<li>AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</li>
<li>AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。</li>
</ul>
<p><strong>AOF 的缺点</strong></p>
<ul>
<li>对于具有相同数据的的 Redis，AOF 文件通常会比 RDB文件体积更大。</li>
<li>虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</li>
<li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。</li>
</ul>
</blockquote>
<h2 id="Redis-VS-memcache"><a href="#Redis-VS-memcache" class="headerlink" title="Redis VS. memcache"></a>Redis VS. memcache</h2><p>1、Redis和Memcache都是将数据存放在内存中。不过memcache还可用于缓存其他东西，例如图片、视频等等</p>
<p>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。 </p>
<p>3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘 . </p>
<p>4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10 </p>
<p>5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从 </p>
<p><strong>6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）,支持持久化，服务器重启，缓存依然可以获取。(这个很重要哦)</strong></p>
<p> 7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复</p>
<p> 8、Redis支持数据的备份，即master-slave模式的数据备份。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/java_review_1_20190226/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/java_review_1_20190226/" itemprop="url">Java复习（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T00:00:00+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java复习日记（一）"><a href="#Java复习日记（一）" class="headerlink" title="Java复习日记（一）"></a>Java复习日记（一）</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>这里<a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">博主海子的描述</a>更为详细，就不在此献丑了。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。</p>
<blockquote>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
</blockquote>
<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<p><strong>1.原子性</strong></p>
<p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>　　请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;  <span class="comment">//1</span></span><br><span class="line">y = x;   <span class="comment">//2</span></span><br><span class="line">x++;    <span class="comment">//3</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p> 　　<strong>所以上面4个语句只有语句1的操作具备原子性。</strong></p>
<p>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p><strong>2.可见性</strong></p>
<p>　　对于可见性，Java提供了<strong>volatile关键字</strong>来保证可见性。</p>
<p>　　<em>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</em></p>
<p>　　<em>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</em></p>
<p>　　另外，通过<strong>synchronized</strong>和<strong>Lock</strong>也能够保证可见性，<strong>synchronized</strong>和<strong>Lock</strong>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<p><strong>3.有序性</strong></p>
<p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>　　在Java里面，可以通过<strong>volatile</strong>关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>这里介绍一下volatile，一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>　　2）禁止进行指令重排序。</p>
<p>　　先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">//线程1``boolean` `stop = ``false``;``while``(!stop)&#123;``    ``doSomething();``&#125;` `//线程2``stop = ``true``;`</span></span><br></pre></td></tr></table></figure>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<blockquote>
<p>　　下面解释一下这段代码为何有可能导致无法中断线程。每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>　　但是用volatile修饰之后就变得不一样了：</p>
<p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>　　那么线程1读取到的就是最新的正确的值。</p>
</blockquote>
<p><strong>但是volatile没办法保证对变量的操作的原子性，可以部分保证有序性：</strong></p>
<blockquote>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/MySQL_learn_1_20190225/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/MySQL_learn_1_20190225/" itemprop="url">MySQL的一些学习过程（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL学习日记-一"><a href="#MySQL学习日记-一" class="headerlink" title="MySQL学习日记(一)"></a>MySQL学习日记(一)</h1><h2 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h2><p>索引在MySQL中也叫做“<strong>键</strong>”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能<br>非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。<br>索引优化应该是<em>对查询性能优化最有效的手段</em>了。索引能够轻易将查询性能提高好几个数量级。</p>
<p>首先，我们知道磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，<strong>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内</strong>，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<p><strong>索引的数据结构</strong>：任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p>
<p><img src="/images/MySQL/B+tree.png" alt></p>
<p>如上图，是一颗b+树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），真实的数据存在于叶子节点，非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<p><strong>b+树的查找过程</strong>：如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<p>因此，我们可以总结出：</p>
<blockquote>
<ol>
<li><strong>索引字段要尽量的小</strong>：通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有$$h = \log_mN$$，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li>
<li><strong>索引的最左匹配特性（即从左往右匹配）</strong>：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</li>
</ol>
</blockquote>
<p><strong>MySQL的索引分类</strong>:</p>
<blockquote>
<p>索引分类<br>1.普通索引index :加速查找<br>2.唯一索引<br>    主键索引：primary key ：加速查找+约束（不为空且唯一）<br>    唯一索引：unique：加速查找+约束 （唯一）<br>3.联合索引<br>    -primary key(id,name):联合主键索引<br>    -unique(id,name):联合唯一索引<br>    -index(id,name):联合普通索引<br>4.全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。<br>5.空间索引spatial :了解就好，几乎不用</p>
</blockquote>
<p> 索引的两大类型hash与btree:</p>
<ul>
<li>hash类型的索引：查询单条快，范围查询慢</li>
<li>btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）。</li>
</ul>
<p><strong>创建/删除索引的语法</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：创建表时</span></span><br><span class="line">     　<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">                字段名<span class="number">1</span>  数据类型 [完整性约束条件…],</span><br><span class="line">                字段名<span class="number">2</span>  数据类型 [完整性约束条件…],</span><br><span class="line">                [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL ]   <span class="keyword">INDEX</span> | <span class="keyword">KEY</span></span><br><span class="line">                [索引名]  (字段名[(长度)]  [<span class="keyword">ASC</span> |<span class="keyword">DESC</span>]) </span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：CREATE在已存在的表上创建索引</span></span><br><span class="line">        <span class="keyword">CREATE</span>  [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL ]  <span class="keyword">INDEX</span>  索引名 </span><br><span class="line">                     <span class="keyword">ON</span> 表名 (字段名[(长度)]  [<span class="keyword">ASC</span> |<span class="keyword">DESC</span>]) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法三：ALTER TABLE在已存在的表上创建索引</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span>  [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL ] <span class="keyword">INDEX</span></span><br><span class="line">                             索引名 (字段名[(长度)]  [<span class="keyword">ASC</span> |<span class="keyword">DESC</span>]) ;</span><br><span class="line">                             </span><br><span class="line"><span class="comment">#删除索引：DROP INDEX 索引名 ON 表名字;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.创建索引</span><br><span class="line">    -在创建表时就创建（需要注意的几点）</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> s1(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> ,<span class="comment">#可以在这加primary key</span></span><br><span class="line">    <span class="comment">#id int index #不可以这样加索引，因为index只是索引，没有约束一说，</span></span><br><span class="line">    <span class="comment">#不能像主键，还有唯一约束一样，在定义字段的时候加索引</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="built_in">int</span>,</span><br><span class="line">    email <span class="built_in">varchar</span>(<span class="number">30</span>)</span><br><span class="line">    <span class="comment">#primary key(id) #也可以在这加</span></span><br><span class="line">    <span class="keyword">index</span>(<span class="keyword">id</span>) <span class="comment">#可以这样加</span></span><br><span class="line">    );</span><br><span class="line">    -在创建表后在创建</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">index</span> <span class="keyword">name</span> <span class="keyword">on</span> s1(<span class="keyword">name</span>); <span class="comment">#添加普通索引</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">unique</span> age <span class="keyword">on</span> s1(age);添加唯一索引</span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> s1 <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>); <span class="comment">#添加住建索引，也就是给id字段增加一个主键约束</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">index</span> <span class="keyword">name</span> <span class="keyword">on</span> s1(<span class="keyword">id</span>,<span class="keyword">name</span>); <span class="comment">#添加普通联合索引</span></span><br><span class="line">2.删除索引</span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">id</span> <span class="keyword">on</span> s1;</span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">name</span> <span class="keyword">on</span> s1; <span class="comment">#删除普通索引</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">index</span> age <span class="keyword">on</span> s1; <span class="comment">#删除唯一索引，就和普通索引一样，不用在index前加unique来删，直接就可以删了</span></span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> s1 <span class="keyword">drop</span> primary <span class="keyword">key</span>; <span class="comment">#删除主键(因为它添加的时候是按照alter来增加的，那么我们也用alter来删)</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/OS_review_1_20190222/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/OS_review_1_20190222/" itemprop="url">操作系统复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T00:00:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="操作系统复习日记"><a href="#操作系统复习日记" class="headerlink" title="操作系统复习日记"></a>操作系统复习日记</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/DB_review_1_20190222/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/DB_review_1_20190222/" itemprop="url">数据库基础复习（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T00:00:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库复习笔记（一）"><a href="#数据库复习笔记（一）" class="headerlink" title="数据库复习笔记（一）"></a>数据库复习笔记（一）</h1><h2 id="1-事务（transaction）"><a href="#1-事务（transaction）" class="headerlink" title="1. 事务（transaction）"></a>1. 事务（transaction）</h2><p><strong>事务</strong>是访问并可能更新数据项的的一个程序执行单元。</p>
<p>事务具有<strong>ACID</strong>特性：</p>
<ol>
<li><p><strong>原子性Atomicity</strong>：事务的所有操作要么<strong>全部正确</strong>反映出来，要么<strong>完全不反应</strong>。</p>
<blockquote>
<p>事务如果不成功执行，称为<strong>中止aborted</strong>，为了确保原子性，中止事务必须对数据库的状态不造成影响，于是使用回滚<strong>rollback</strong>。典型的方法就是维护一个<strong>日志log</strong>。</p>
</blockquote>
</li>
<li><p><strong>一致性Consistency</strong>：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。</p>
<blockquote>
<p>如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。</p>
<p>如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p>
</blockquote>
</li>
<li><p><strong>隔离性Isolation</strong>：尽管多个事务可能并发执行，但是系统保证每个事务都感觉不到系统有其他事务在执行。</p>
<blockquote>
<p>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
</blockquote>
</li>
<li><p><strong>持久性Durability</strong>：一个事务一旦完成，它对数据库的改变必须是永久的，即使系统出现故障，也不会因此而失去改动。</p>
</li>
</ol>
<p>在<strong>MySQL</strong>中，事务的ACID由<strong>InnoDB</strong>存储引擎的日志和锁保证的，事务的<strong>隔离性</strong>是通过<strong>数据库锁</strong>的机制实现的，<strong>持久性</strong>通过 <strong>Redo Log（重做日志）</strong>来实现，<strong>原子性和一致性</strong>通过 <strong>Undo Log</strong> 来实现。</p>
<p><img src="/images/DB/InnoDB_ACID.png" alt></p>
<blockquote>
<p><strong>Undo Log</strong> 的原理很简单，为了满足事务的<strong>原子性</strong>，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 <strong>Undo Log</strong>）。然后进行数据的修改。</p>
<p>如果出现了错误或者用户执行了 Rollback 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。</p>
<p>和 Undo Log <strong>相反</strong>，<strong>Redo Log</strong> 记录的是<em>新数据的备份</em>。在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。</p>
<p>当系统崩溃时，虽然数据没有持久化，<em>但是 Redo Log 已经持久化</em>。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态。</p>
</blockquote>
<h3 id="关于隔离性："><a href="#关于隔离性：" class="headerlink" title="关于隔离性："></a>关于隔离性：</h3><p><strong>首先，先介绍并发下事务会产生的问题：</strong></p>
<p>举个例子，事务A和事务B操纵的是同一个资源，事务A有若干个子事务，事务B也有若干个子事务，事务A和事务B在高并发的情况下，会出现各种各样的问题。总结一下主要就是五种：第一类丢失更新、第二类丢失更新、脏读、不可重复读、幻读。五种之中，第一类丢失更新、第二类丢失更新不重要，不讲了，讲一下脏读、不可重复读和幻读。</p>
<p><strong>1、脏读</strong></p>
<blockquote>
<p>所谓脏读，就是指<strong><u>事务A读到了事务B还没有提交的数据</u></strong>，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务–&gt;取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。</p>
</blockquote>
<p><strong>2、不可重复读</strong></p>
<blockquote>
<p>所谓不可重复读，就是指<strong><u>在一个事务里面读取了两次某个数据，读出来的数据<em>不一致</em></u></strong>。还是以银行取钱为例，事务A开启事务–&gt;查出银行卡余额为1000元，此时切换到事务B事务B开启事务–&gt;事务B取走100元–&gt;提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。</p>
</blockquote>
<p><strong>3、幻读</strong></p>
<blockquote>
<p>所谓幻读，就是指<strong><u>在一个事务里面的操作中发现了未被操作的数据</u></strong>。比如学生信息，事务A开启事务–&gt;修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务–&gt;事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。<em>幻读出现的前提是并发的事务中有事务发生了插入、删除操作。</em></p>
</blockquote>
<h3 id="事务隔离级别："><a href="#事务隔离级别：" class="headerlink" title="事务隔离级别："></a>事务隔离级别：</h3><p>事务隔离级别，就是为了解决上面几种问题而诞生的。为什么要有事务隔离级别，因为<strong>事务隔离级别越高，在并发下会产生的问题就越少，但同时付出的性能消耗也将越大</strong>，因此很多时候必须<u>在并发性和性能之间做一个权衡</u>。所以设立了几种事务隔离级别，以便让不同的项目可以根据自己项目的并发情况选择合适的事务隔离级别，对于在事务隔离级别之外会产生的并发问题，在代码中做补偿。</p>
<p>事务隔离级别有4种，但是像Spring会提供给用户5种，来看一下：</p>
<p><strong>1、DEFAULT</strong></p>
<p><strong>默认隔离级别</strong>，每种数据库支持的事务隔离级别不一样，如果Spring配置事务时将isolation设置为这个值的话，那么将使用底层数据库的默认事务隔离级别。顺便说一句，如果使用的MySQL，可以使用”<strong>select @@tx_isolation</strong>“来查看默认的事务隔离级别</p>
<p><strong>2、未提交读READ_UNCOMMITTED</strong></p>
<p>未提交读，<strong>即能够读取到没有被提交的数据</strong>，所以很明显这个级别的隔离机制<strong><em>无法解决脏读、不可重复读、幻读中的任何一种</em></strong>，因此很少使用。</p>
<p><strong>3、已提交读READ_COMMITED</strong></p>
<p>已提交读，即<strong>能够读到那些已经提交的数据</strong>，<strong><em>自然能够防止脏读，但是无法限制不可重复读和幻读</em></strong>。</p>
<p><strong>4、可重复读REPEATABLE_READ</strong></p>
<p>重复读取，即在<strong>数据读出来之后加锁</strong>，类似”select <em> from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，**</em>这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决<em>**。</em>是innoDB的默认事务隔离级别。*</p>
<blockquote>
<p>READ_COMMITED(RC)和REPEATABLE_READ(RR)是innoDB里面使用范围最广的隔离级别。</p>
</blockquote>
<p><strong>5、可串行化SERLALIZABLE</strong></p>
<p>串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了。</p>
<p><img src="/images/DB/isolation_table.png" alt></p>
<h3 id="事务隔离技术：MVCC与NEXT-KEY-LOCKING"><a href="#事务隔离技术：MVCC与NEXT-KEY-LOCKING" class="headerlink" title="事务隔离技术：MVCC与NEXT-KEY LOCKING"></a>事务隔离技术：MVCC与NEXT-KEY LOCKING</h3><p><strong>MVCC多版本并发控制（Multiversion Currency Control）</strong>：一般情况下，事务性储存引擎不是只使用表锁，行加锁的处理数据，而是结合了MVCC机制，以处理更多的并发问题。Mvcc处理高并发能力最强，但系统开销比最大（较表锁、行级锁），这是最求高并发付出的代价。</p>
<blockquote>
<p><strong>InnoDB实现MVCC的方法是，它存储了每一行的三个额外的隐藏字段:</strong></p>
<ol>
<li><p><strong>DB_TRX_ID</strong>：一个6byte的标识，每处理一个事务，其值自动+1<br>#下面提到的“创建时间”和“删除时间”记录的就是这个DB_TRX_ID的值<br>#如insert、update、delete操作时，删除操作用1个bit表示。<br>#<strong>DB_TRX_ID是最重要的一个</strong>，可以通过语句“show engine innodb status”来查找 </p>
</li>
<li><p><strong>DB_ROLL_PTR</strong>: 大小是7byte,指向写到rollback segment（回滚段）的一条undo log记录<br> （update操作的话，记录update前的ROW值）</p>
</li>
<li><p><strong>DB_ROW_ID</strong>: 大小是6byte,该值随新行插入单调增加</p>
</li>
</ol>
</blockquote>
<p>MVCC只工作在<strong>REPEATABLE READ</strong>和<strong>READ COMMITED</strong>隔离级别下：</p>
<blockquote>
<ol>
<li>READ UNCOMMITTED ，不适用MVCC读，可以读到其他事务修改甚至未提交的</li>
<li>READ COMMITTED ，其他事务对数据库的修改,只要已经提交,其修改的结果就是可见的,<br>与这两个事务开始的先后顺序无关，不完全适用于MVCC读，</li>
<li>REPEATABLE READ，可重复读，完全适用MVCC，只能读取在它开始之前已经提交的事务对数据库的修改,<br>在它开始以后,所有其他事务对数据库的修改对它来说均不可见</li>
<li>SERIALIZABLE ，完全不适合适用MVCC，这样所有的query都会加锁，再它之后的事务都要等待 </li>
</ol>
</blockquote>
<p><strong>NEXT-KEY LOCKING</strong>：InnoDB中的RR级别作为范围如此广的隔离级别，其通过NEXT-KEY locking技术解决幻读问题，<strong>就是锁住一个范围</strong>：<em>例如：A追求一个女生，使用了NEXT-KEY LOCKING技术，即使得A在追求时要跟女孩说，只要我开始追求你，问了你有没有男朋友，在我结束追求你之前，你不可以答应别人的追求！我要把你脑子里记录男朋友的区域全部锁起来！</em></p>
<p><img src="/images/DB/nextkeylock.png" alt="幻读问题在RR下的解决"></p>
<hr>
<h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h2><p>锁主要为<strong>共享锁</strong>和<strong>排他锁</strong>。</p>
<p>两段锁协议：两段锁协议规定所有的事务应遵守的规则：<br>　　① 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。<br>　　② 在释放一个封锁之后，事务不再申请和获得其它任何封锁。<br>　　即事务的执行分为两个阶段：<br>　　第一阶段是获得封锁的阶段，称为<strong>扩展阶段</strong>。第二阶段是释放封锁的阶段，称为<strong>收缩阶段</strong>。</p>
<p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。<em>Java里面的同步原语synchronized关键字的实现也是悲观锁。</em></p>
<p><strong>乐观锁</strong>：顾名思义，就是很乐观，假设认为数据一般情况下不会产生并发冲突，所以在数据进行提交更新的时候，才会正式对数据是否产生并发冲突进行检测，如果发现并发冲突了，则让返回用户错误的信息，让用户决定如何去做，可以使用版本号等机制。乐观锁适用于<strong>多读的应用类型</strong>，这样可以提高吞吐量。</p>
<blockquote>
<p>乐观锁的一种实现方式-<strong>CAS(Compare and Swap 比较并交换)</strong>：主要就是两个步骤：<strong>冲突检测</strong>和<strong>数据更新</strong></p>
</blockquote>
<blockquote>
<p><strong>CAS与Synchronized的使用情景：</strong>　</p>
<ol>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ol>
</blockquote>
<p><strong>隐式锁Synchronized</strong>：synchronized是Java的关键字，悲观锁的一种，当它用来修饰一个方法或一个代码块时，能够保证在同一时刻最多只有一个线程执行该代码。因为当调用Synchronized修饰的代码时，并不需要显示的加锁和解锁的过程，所以称之为隐式锁。</p>
<blockquote>
<p>synchronized在JVM上实现；针对一个对象。</p>
</blockquote>
<p><strong>显式锁Lock</strong>：Lock是一个<strong>接口</strong>，提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有的加锁和解锁操作方法都是显示的，因而称为显示锁。 主要有以下几个实现类：<em>ReentrantLock</em>（可重入锁）、<em>ReentrantReadWriteLock.ReadLock</em>和<em>ReentrantReadWriteLock.WriteLock</em>。记住，每次上锁，都务必记得解锁。</p>
<blockquote>
<p>ReentrantLock和ReentrantReadWriteLock是代码块层面的锁定，而且需要显式的加解锁。</p>
</blockquote>
<p><strong>快照读</strong>：读取的是记录数据的可见版本（可能是过期的数据），不用加锁。</p>
<p><strong>当前读</strong>：读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录。</p>
<hr>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。说白了就是<strong>一张数据表的表结构所符合的某种设计标准的级别</strong>。范式级别越高，表的设计就越标准。</p>
<p><img src="/images/DB/fanshi_relation.png" alt="各范式关系"></p>
<p><strong>第一范式</strong>：第一范式是数据库表需要符合的最基本条件：表的每一个属性不能是再可分的数据项。</p>
<p><img src="/images/DB/fanshi_1.jpg" alt></p>
<p><strong>第二范式</strong>：第二范式就是在第一范式的基础之上消除了非主属性对码的部分依赖 。</p>
<p><strong>第三范式</strong>：就是在第二范式的基础上再消除了非主属性对码的传递依赖。</p>
<p><strong>BCNF</strong>：就是在第三范式的基础上消除了主属性对码的部分依赖和传递依赖。</p>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p><strong>drop，truncate和delete的区别</strong>：</p>
<blockquote>
<ol>
<li>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</li>
</ol>
<p>​       TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行    是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<ol start="2">
<li><p>表和索引所占空间。</p>
<p>当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，</p>
<p>DELETE操作不会减少表或索引所占用的空间。</p>
</li>
</ol>
<p>​       drop语句将表所占用的空间全释放掉。</p>
<ol start="3">
<li><p>速度上，一般而言，drop &gt; truncate &gt; delete</p>
</li>
<li><p>应用范围。</p>
<p>TRUNCATE 只能对TABLE；         DELETE可以是table和view</p>
</li>
<li><p>TRUNCATE 和DELETE只删除数据， DROP则删除整个表（结构和数据）。</p>
</li>
</ol>
</blockquote>
<h2 id="视图View"><a href="#视图View" class="headerlink" title="视图View"></a>视图View</h2><p>有时候我们不想用户看到所有的逻辑模型，会使用视图。视图有很多用处，比如一个比较复杂的查询不想每次都写很多语句，就可以写个视图；或者给特定用户开放某些表的读取权限，但要加一些行和列的限制，也可以写个视图。</p>
<p>视图的好处，可以主要分为四点： </p>
<ol>
<li><p>使用视图，可以定制用户数据，<strong>聚焦特定的数据</strong>。  </p>
<blockquote>
<p>在实际过程中，公司有不同角色的工作人员，我们以销售公司为例的话，<br>采购人员，可以需要一些与其有关的 数据，而与他无关的数据，对他没<br>有任何意义，我们可以根据这一实际情况，专门为采购人员创建一个视<br>图，以后他在查询数据时，只需select   *   from   view_caigou   就可以啦。 </p>
</blockquote>
</li>
<li><p>使用视图，可以<strong>简化数据操作</strong>。 </p>
<blockquote>
<p>我们在使用查询时，在很多时候我们要使用聚合函数，同时还要<br>显示其它字段的信息，可能还会需要关联到其它表，这时写的语句可能<br>会很长很复杂，如果这个动作频繁发生的话，我们可以创建视图，这以后，我<br>们只需要select   *   from   view1就可以啦。 </p>
</blockquote>
</li>
<li><p>使用视图，基表中的数据就有了一定的<strong>安全性</strong> 。</p>
<blockquote>
<p>因为视图是虚拟的，物理上是不存在的，只是存储了数据的集合，我们可以<br>将基表中重要的字段信息，可以不通过视图给用户，视图是动态的数据的集<br>合，数据是随着基表的更新而更新。同时，用户对视图，不可以随意的更改<br>和删除，可以保证数据的安全性。 </p>
</blockquote>
</li>
<li><p>可以<strong>合并分离的数据</strong>，创建分区视图。 </p>
<blockquote>
<p>随着社会的发展，公司的业务量的不断的扩大，一个大公司，下属都设有很<br>多的分公司，为了管理方便，我们需要统一表的结构，定期查看各公司业务<br>情况，而分别看各个公司的数据很不方便，没有很好的可比性，如果将这些<br>数据合并为一个表格里，就方便多啦，这时我们就可以使用union关键字，<br>将各分公司的数据合并为一个视图。</p>
</blockquote>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/Lucene_learn_1_20190222/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/Lucene_learn_1_20190222/" itemprop="url">Lucene入门学习及介绍（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T00:00:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/lucene/logo.png" alt="logo"></p>
<p>学习并转载自：<a href="https://www.cnblogs.com/xiaobai1226/p/7652093.html" target="_blank" rel="noopener">博客园高压锅里的小白-Lucene介绍与入门使用</a></p>
<h1 id="Lucene简介"><a href="#Lucene简介" class="headerlink" title="Lucene简介"></a>Lucene简介</h1><p>　　Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了<strong>完整的查询引擎和索引引擎</strong>，<strong>部分文本分析引擎（英文与德文两种西方语言）</strong>。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。<u><em>人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。</em></u></p>
<h3 id="那么先来说一说什么是全文搜索"><a href="#那么先来说一说什么是全文搜索" class="headerlink" title="　　那么先来说一说什么是全文搜索"></a>　　那么先来说一说什么是全文搜索</h3><p>　　说之前先说一说<strong>数据的分类</strong>：　</p>
<p>　　　　我们生活中的数据总体分为两种：结构化数据和非结构化数据。</p>
<p>　　　　（1）<strong>结构化数据</strong>：指具有固定格式或有限长度的数据，如数据库，元数据等。</p>
<p>　　　　（2）<strong>非结构化数据</strong>：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件</p>
<h2 id="结构化数据查询方法"><a href="#结构化数据查询方法" class="headerlink" title="　　结构化数据查询方法"></a>　　结构化数据查询方法</h2><h3 id="数据库搜索"><a href="#数据库搜索" class="headerlink" title="　　数据库搜索"></a>　　数据库搜索</h3><p>　　数据库中的搜索很容易实现，通常都是使用sql语句进行查询，而且能很快的得到查询结果。</p>
<p>　　为什么数据库搜索很容易？</p>
<p>　　因为数据库中的数据存储是有规律的，有行有列而且数据格式、数据长度都是固定的。</p>
<h2 id="非结构化数据查询方法"><a href="#非结构化数据查询方法" class="headerlink" title="　　非结构化数据查询方法"></a>　　非结构化数据查询方法</h2><p>　　<strong>（1）</strong> <strong>顺序扫描法</strong> <strong>(Serial Scanning)</strong></p>
<p>　　所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是<strong>相当的慢</strong>。</p>
<p>　　<strong>（2）</strong> <strong>全文检索</strong> <strong>(Full-text Search)</strong></p>
<p>　　将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之<strong>索引</strong>。</p>
<p>　　<strong>这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。</strong></p>
<p>　　虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。</p>
<h3 id="全文检索的应用场景"><a href="#全文检索的应用场景" class="headerlink" title="　　全文检索的应用场景"></a>　　全文检索的应用场景</h3><p>　　对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。</p>
<h1 id="Lucene实现全文检索的流程"><a href="#Lucene实现全文检索的流程" class="headerlink" title="　　Lucene实现全文检索的流程"></a>　　Lucene实现全文检索的流程</h1><h3 id="索引和搜索流程图"><a href="#索引和搜索流程图" class="headerlink" title="　　索引和搜索流程图"></a>　　索引和搜索流程图</h3><p><img src="/images/lucene/index_search.png" alt></p>
<p>1、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：</p>
<p>　　　　确定原始内容即要搜索的内容→采集文档→创建文档→分析文档→索引文档</p>
<p>　　2、红色表示搜索过程，从索引库中搜索内容，搜索过程包括：</p>
<p>　　　　用户通过搜索界面→创建查询→执行搜索，从索引库搜索→渲染搜索结果</p>
<p>　　接下来详细讲解一下这张图片：　</p>
<h2 id="1，创建索引"><a href="#1，创建索引" class="headerlink" title="　1，创建索引"></a>　1，创建索引</h2><p>　　对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。</p>
<p>这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。</p>
<h3 id="1-1-1-获得原始文档"><a href="#1-1-1-获得原始文档" class="headerlink" title="　　1.1.1.   获得原始文档"></a>　　1.1.1.   获得原始文档</h3><p>　　<strong>原始文档</strong>是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。</p>
<p>　　从互联网上、数据库、文件系统中等获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来。</p>
<p>​        Lucene不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，如下：</p>
<p>​         （1）<a href="http://lucene.apache.org/nutch" target="_blank" rel="noopener">Nutch</a>：Nutch是apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。</p>
<p>​         （2）<a href="http://jsoup.org/" target="_blank" rel="noopener">jsoup</a>：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p>
<p>​         （3）<a href="http://sourceforge.net/projects/archive-crawler/files/" target="_blank" rel="noopener">Heritrix</a>：Heritrix 是一个由 java 开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。</p>
<p>　　本案例我们要获取磁盘上文件的内容，可以通过文件流来读取文本文件的内容，对于pdf、doc、xls等文件可通过第三方提供的解析工具读取文件内容，比如Apache POI读取doc和xls的文件内容。 </p>
<h3 id="1-1-2-创建文档对象"><a href="#1-1-2-创建文档对象" class="headerlink" title="1.1.2.   创建文档对象"></a>1.1.2.   创建文档对象</h3><p>　　获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。</p>
<p>这里我们可以将磁盘上的一个文件当成一个document，Document中包括一些Field（file_name文件名称、file_path文件路径、file_size文件大小、file_content文件内容）:</p>
<p><img src="/images/lucene/document_stru.png" alt></p>
<blockquote>
<p> 注意：（1）每个Document可以有多个Field</p>
<p>​            （2）不同的Document可以有不同的Field</p>
<p>​            （3）同一个Document可以有相同的Field（域名和域值都相同）</p>
<p>​            （4）每个文档都有一个唯一的编号，就是文档id。</p>
</blockquote>
<h3 id="1-1-3-分析文档"><a href="#1-1-3-分析文档" class="headerlink" title="1.1.3.   分析文档"></a>1.1.3.   分析文档</h3><p>　　将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。每个单词叫做一个<strong>Term</strong>，不同的域中拆分出来的相同的单词是不同的term。term中包含两部分一部分是文档的域名，另一部分是单词的内容。</p>
<h3 id="1-1-4-创建索引"><a href="#1-1-4-创建索引" class="headerlink" title="1.1.4.   创建索引"></a>1.1.4.   创建索引</h3><p>　　对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到Document（文档）。</p>
<p><img src="/images/lucene/indexDB_stru.png" alt></p>
<blockquote>
<p>注意：（1）创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫<strong>倒排索引结构</strong>。　　　　　       （2）传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。</p>
<p>​         <strong>（3）倒排索引结构</strong>是根据内容（词语）找文档，<strong>倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。</strong>如下图：</p>
</blockquote>
<p><img src="/images/lucene/table.png" alt></p>
<p><strong>创建索引代码实例：</strong></p>
<p>　　新建一个Java工程，导入相关的jar包</p>
<p><img src="/images/lucene/dir_jar.png" alt></p>
<p>编写创建索引代码</p>
<p>　　使用indexwriter对象创建索引</p>
<blockquote>
<p>　　<strong>具体步骤：</strong></p>
<p>　　第一步：创建一个indexwriter对象。</p>
<p>　　　　1）指定索引库的存放位置Directory对象</p>
<p>　　　　2）指定一个分析器，对文档内容进行分析。</p>
<p>　　第二步：创建document对象。</p>
<p>　　第三步：创建field对象，将field添加到document对象中。</p>
<p>　　第四步：使用indexwriter对象将document对象写入索引库，此过程进行索引创建。并将索引和document对象写入索引库。</p>
<p>　　第五步：关闭IndexWriter对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>     <span class="comment">//创建索引</span></span><br><span class="line"> <span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"> <span class="number">3</span>         <span class="comment">//指定索引库的存放位置Directory对象</span></span><br><span class="line"> <span class="number">4</span>         Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line"> <span class="number">5</span>         <span class="comment">//索引库还可以存放到内存中</span></span><br><span class="line"> <span class="number">6</span>         <span class="comment">//Directory directory = new RAMDirectory();</span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>         <span class="comment">//指定一个标准分析器，对文档内容进行分析</span></span><br><span class="line"> <span class="number">9</span>         Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line"><span class="number">10</span>         </span><br><span class="line"><span class="number">11</span>         <span class="comment">//创建indexwriterCofig对象</span></span><br><span class="line"><span class="number">12</span>         <span class="comment">//第一个参数： Lucene的版本信息，可以选择对应的lucene版本也可以使用LATEST</span></span><br><span class="line"><span class="number">13</span>         <span class="comment">//第二根参数：分析器对象</span></span><br><span class="line"><span class="number">14</span>         IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(Version.LATEST, analyzer);</span><br><span class="line"><span class="number">15</span>         </span><br><span class="line"><span class="number">16</span>         <span class="comment">//创建一个indexwriter对象</span></span><br><span class="line"><span class="number">17</span>         IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, config);</span><br><span class="line"><span class="number">18</span>         </span><br><span class="line"><span class="number">19</span>         <span class="comment">//原始文档的路径</span></span><br><span class="line"><span class="number">20</span>         File file = <span class="keyword">new</span> File(<span class="string">"E:\\programme\\searchsource"</span>);</span><br><span class="line"><span class="number">21</span>         File[] fileList = file.listFiles();</span><br><span class="line"><span class="number">22</span>         <span class="keyword">for</span> (File file2 : fileList) &#123;</span><br><span class="line"><span class="number">23</span>             <span class="comment">//创建document对象</span></span><br><span class="line"><span class="number">24</span>             Document document = <span class="keyword">new</span> Document();</span><br><span class="line"><span class="number">25</span>             </span><br><span class="line"><span class="number">26</span>             <span class="comment">//创建field对象，将field添加到document对象中</span></span><br><span class="line"><span class="number">27</span>             </span><br><span class="line"><span class="number">28</span>             <span class="comment">//文件名称</span></span><br><span class="line"><span class="number">29</span>             String fileName = file2.getName();</span><br><span class="line"><span class="number">30</span>             <span class="comment">//创建文件名域</span></span><br><span class="line"><span class="number">31</span>             <span class="comment">//第一个参数：域的名称</span></span><br><span class="line"><span class="number">32</span>             <span class="comment">//第二个参数：域的内容</span></span><br><span class="line"><span class="number">33</span>             <span class="comment">//第三个参数：是否存储</span></span><br><span class="line"><span class="number">34</span>             Field fileNameField = <span class="keyword">new</span> TextField(<span class="string">"fileName"</span>, fileName, Store.YES);</span><br><span class="line"><span class="number">35</span>             </span><br><span class="line"><span class="number">36</span>             <span class="comment">//文件的大小</span></span><br><span class="line"><span class="number">37</span>             <span class="keyword">long</span> fileSize  = FileUtils.sizeOf(file2);</span><br><span class="line"><span class="number">38</span>             <span class="comment">//文件大小域</span></span><br><span class="line"><span class="number">39</span>             Field fileSizeField = <span class="keyword">new</span> LongField(<span class="string">"fileSize"</span>, fileSize, Store.YES);</span><br><span class="line"><span class="number">40</span>             </span><br><span class="line"><span class="number">41</span>             <span class="comment">//文件路径</span></span><br><span class="line"><span class="number">42</span>             String filePath = file2.getPath();</span><br><span class="line"><span class="number">43</span>             <span class="comment">//文件路径域（不分析、不索引、只存储）</span></span><br><span class="line"><span class="number">44</span>             Field filePathField = <span class="keyword">new</span> StoredField(<span class="string">"filePath"</span>, filePath);</span><br><span class="line"><span class="number">45</span>             </span><br><span class="line"><span class="number">46</span>             <span class="comment">//文件内容</span></span><br><span class="line"><span class="number">47</span>             String fileContent = FileUtils.readFileToString(file2);</span><br><span class="line"><span class="number">48</span>             <span class="comment">//String fileContent = FileUtils.readFileToString(file2, "utf-8");</span></span><br><span class="line"><span class="number">49</span>             <span class="comment">//文件内容域</span></span><br><span class="line"><span class="number">50</span>             Field fileContentField = <span class="keyword">new</span> TextField(<span class="string">"fileContent"</span>, fileContent, Store.YES);</span><br><span class="line"><span class="number">51</span>             </span><br><span class="line"><span class="number">52</span>             document.add(fileNameField);</span><br><span class="line"><span class="number">53</span>             document.add(fileSizeField);</span><br><span class="line"><span class="number">54</span>             document.add(filePathField);</span><br><span class="line"><span class="number">55</span>             document.add(fileContentField);</span><br><span class="line"><span class="number">56</span>             <span class="comment">//使用indexwriter对象将document对象写入索引库，此过程进行索引创建。并将索引和document对象写入索引库。</span></span><br><span class="line"><span class="number">57</span>             indexWriter.addDocument(document);</span><br><span class="line"><span class="number">58</span>         &#125;</span><br><span class="line"><span class="number">59</span>         <span class="comment">//关闭IndexWriter对象。</span></span><br><span class="line"><span class="number">60</span>         indexWriter.close();</span><br><span class="line"><span class="number">61</span>     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Field域的属性概述"><a href="#Field域的属性概述" class="headerlink" title="Field域的属性概述"></a>Field域的属性概述</h2><p>　　<strong>是否分析</strong>：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。</p>
<p>　　<strong>是否索引</strong>：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。</p>
<p>　　比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。</p>
<p>　　<strong>是否存储</strong>：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取</p>
<p>　　比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。</p>
<p>　　<strong>是否存储的标准：是否要将内容展示给用户</strong></p>
<table>
<thead>
<tr>
<th>Field类</th>
<th>数据类型</th>
<th>Analyzed是否分析</th>
<th>Indexed是否索引</th>
<th>Stored是否存储</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>StringField(FieldName, FieldValue,Store.YES))</td>
<td>字符串</td>
<td>N</td>
<td>Y</td>
<td>Y或N</td>
<td>这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)是否存储在文档中用Store.YES或Store.NO决定</td>
</tr>
<tr>
<td>LongField(FieldName, FieldValue,Store.YES)</td>
<td>Long型</td>
<td>Y</td>
<td>Y</td>
<td>Y或N</td>
<td>这个Field用来构建一个Long数字型Field，进行分析和索引，比如(价格)是否存储在文档中用Store.YES或Store.NO决定</td>
</tr>
<tr>
<td>StoredField(FieldName, FieldValue)</td>
<td>重载方法，支持多种类型</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>这个Field用来构建不同类型Field不分析，不索引，但要Field存储在文档中</td>
</tr>
<tr>
<td>TextField(FieldName, FieldValue, Store.NO)或TextField(FieldName, reader)</td>
<td>字符串或流</td>
<td>Y</td>
<td>Y</td>
<td>Y或N</td>
<td>如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略.</td>
</tr>
</tbody>
</table>
<h2 id="2-查询索引"><a href="#2-查询索引" class="headerlink" title="　　2. 查询索引"></a>　　2. 查询索引</h2><p>　　查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。</p>
<p>​       对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法，类似关系数据库Sql语法一样Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。</p>
<h3 id="2-1-用户查询接口"><a href="#2-1-用户查询接口" class="headerlink" title="　　2.1.   用户查询接口"></a>　　2.1.   用户查询接口</h3><p>　　全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果。</p>
<p>　　比如： 百度搜索</p>
<p>　　Lucene不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面。</p>
<h3 id="2-2-创建查询"><a href="#2-2-创建查询" class="headerlink" title="　　2.2.   创建查询"></a>　　2.2.   创建查询</h3><p>　　用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的Field文档域、查询关键字等，查询对象会生成具体的查询语法，</p>
<p>　　例如： 语法 “fileName:lucene”表示要搜索Field域的内容为“lucene”的文档</p>
<h3 id="2-3-执行查询"><a href="#2-3-执行查询" class="headerlink" title="　　2.3.   执行查询"></a>　　2.3.   执行查询</h3><p>　　搜索索引过程：</p>
<p>　　根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。</p>
<p>　　比如搜索语法为“fileName:lucene”表示搜索出fileName域中包含Lucene的文档。</p>
<p>　　搜索过程就是在索引上查找域为fileName，并且关键字为Lucene的term，并根据term找到文档id列表。</p>
<p>​       可通过两种方法创建查询对象：</p>
<p>​         1）使用Lucene提供Query子类</p>
<p>​         Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。</p>
<p>​         如下代码：</p>
<p>​    　　Query query = <strong>new</strong> TermQuery(<strong>new</strong> Term(“name”, “lucene”));</p>
<p>​         2）使用QueryParse解析查询表达式</p>
<p>​         QueryParse会将用户输入的查询表达式解析成Query对象实例。</p>
<p>​         如下代码：</p>
<p>​           QueryParser queryParser = <strong>new</strong> QueryParser(“name”, <strong>new</strong> IKAnalyzer());</p>
<p>​           Query query = queryParser.parse(“name:lucene”);</p>
<p> 　　</p>
<blockquote>
<p>　　首先，演示第一种方法，<strong>使用query的子类查询</strong></p>
<p>　　<strong>实现步骤</strong></p>
<p>　　第一步：创建一个Directory对象，也就是索引库存放的位置。</p>
<p>　　第二步：创建一个indexReader对象，需要指定Directory对象。</p>
<p>　　第三步：创建一个indexsearcher对象，需要指定IndexReader对象</p>
<p>　　第四步：创建一个Query的子类对象，指定查询的域和查询的关键词。</p>
<p>　　第五步：执行查询。</p>
<p>　　第六步：返回查询结果。遍历查询结果并输出。</p>
<p>　　第七步：关闭IndexReader对象</p>
</blockquote>
<h3 id="MatchAllDocsQuery"><a href="#MatchAllDocsQuery" class="headerlink" title="　　MatchAllDocsQuery"></a>　　MatchAllDocsQuery</h3><p>　　使用MatchAllDocsQuery查询索引目录中的所有文档</p>
<p>　　<strong>具体代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMatchAllDocsQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Directory对象，指定索引库存放的路径</span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line">    <span class="comment">//创建IndexReader对象，需要指定Directory对象</span></span><br><span class="line">    IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line">    <span class="comment">//创建Indexsearcher对象，需要指定IndexReader对象</span></span><br><span class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建查询条件</span></span><br><span class="line">    <span class="comment">//使用MatchAllDocsQuery查询索引目录中的所有文档</span></span><br><span class="line">    Query query = <span class="keyword">new</span> MatchAllDocsQuery();</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    <span class="comment">//第一个参数是查询对象，第二个参数是查询结果返回的最大值</span></span><br><span class="line">    TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询结果的总条数</span></span><br><span class="line">    System.out.println(<span class="string">"查询结果的总条数："</span>+ topDocs.totalHits);</span><br><span class="line">    <span class="comment">//遍历查询结果</span></span><br><span class="line">    <span class="comment">//topDocs.scoreDocs存储了document对象的id</span></span><br><span class="line">    <span class="comment">//ScoreDoc[] scoreDocs = topDocs.scoreDocs;</span></span><br><span class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line">        <span class="comment">//scoreDoc.doc属性就是document对象的id</span></span><br><span class="line">        <span class="comment">//int doc = scoreDoc.doc;</span></span><br><span class="line">        <span class="comment">//根据document的id找到document对象</span></span><br><span class="line">        Document document = indexSearcher.doc(scoreDoc.doc);</span><br><span class="line">        <span class="comment">//文件名称</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileName"</span>));</span><br><span class="line">        <span class="comment">//文件内容</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileContent"</span>));</span><br><span class="line">        <span class="comment">//文件大小</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileSize"</span>));</span><br><span class="line">        <span class="comment">//文件路径</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"filePath"</span>));</span><br><span class="line">        System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭indexreader对象</span></span><br><span class="line">    indexReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TermQuery（精准查询）"><a href="#TermQuery（精准查询）" class="headerlink" title="　　TermQuery（精准查询）"></a>　　TermQuery（精准查询）</h3><p>　　TermQuery，通过项查询，TermQuery不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等。</p>
<p>指定要查询的域和要查询的关键词。</p>
<p>　　<strong>具体代码：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>     <span class="comment">//搜索索引</span></span><br><span class="line"> <span class="number">2</span>     <span class="meta">@Test</span></span><br><span class="line"> <span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"> <span class="number">4</span>         <span class="comment">//创建一个Directory对象，指定索引库存放的路径</span></span><br><span class="line"> <span class="number">5</span>         Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line"> <span class="number">6</span>         <span class="comment">//创建IndexReader对象，需要指定Directory对象</span></span><br><span class="line"> <span class="number">7</span>         IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line"> <span class="number">8</span>         <span class="comment">//创建Indexsearcher对象，需要指定IndexReader对象</span></span><br><span class="line"> <span class="number">9</span>         IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line"><span class="number">10</span>         <span class="comment">//创建一个TermQuery（精准查询）对象，指定查询的域与查询的关键词</span></span><br><span class="line"><span class="number">11</span>         <span class="comment">//创建查询</span></span><br><span class="line"><span class="number">12</span>         Query query = <span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"fileName"</span>, <span class="string">"apache"</span>));</span><br><span class="line"><span class="number">13</span>         <span class="comment">//执行查询</span></span><br><span class="line"><span class="number">14</span>         <span class="comment">//第一个参数是查询对象，第二个参数是查询结果返回的最大值</span></span><br><span class="line"><span class="number">15</span>         TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>);</span><br><span class="line"><span class="number">16</span>         <span class="comment">//查询结果的总条数</span></span><br><span class="line"><span class="number">17</span>         System.out.println(<span class="string">"查询结果的总条数："</span>+ topDocs.totalHits);</span><br><span class="line"><span class="number">18</span>         <span class="comment">//遍历查询结果</span></span><br><span class="line"><span class="number">19</span>         <span class="comment">//topDocs.scoreDocs存储了document对象的id</span></span><br><span class="line"><span class="number">20</span>         <span class="comment">//ScoreDoc[] scoreDocs = topDocs.scoreDocs;</span></span><br><span class="line"><span class="number">21</span>         <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line"><span class="number">22</span>             <span class="comment">//scoreDoc.doc属性就是document对象的id</span></span><br><span class="line"><span class="number">23</span>             <span class="comment">//int doc = scoreDoc.doc;</span></span><br><span class="line"><span class="number">24</span>             <span class="comment">//根据document的id找到document对象</span></span><br><span class="line"><span class="number">25</span>             Document document = indexSearcher.doc(scoreDoc.doc);</span><br><span class="line"><span class="number">26</span>             <span class="comment">//文件名称</span></span><br><span class="line"><span class="number">27</span>             System.out.println(document.get(<span class="string">"fileName"</span>));</span><br><span class="line"><span class="number">28</span>             <span class="comment">//文件内容</span></span><br><span class="line"><span class="number">29</span>             System.out.println(document.get(<span class="string">"fileContent"</span>));</span><br><span class="line"><span class="number">30</span>             <span class="comment">//文件大小</span></span><br><span class="line"><span class="number">31</span>             System.out.println(document.get(<span class="string">"fileSize"</span>));</span><br><span class="line"><span class="number">32</span>             <span class="comment">//文件路径</span></span><br><span class="line"><span class="number">33</span>             System.out.println(document.get(<span class="string">"filePath"</span>));</span><br><span class="line"><span class="number">34</span>             System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line"><span class="number">35</span>         &#125;</span><br><span class="line"><span class="number">36</span>         <span class="comment">//关闭indexreader对象</span></span><br><span class="line"><span class="number">37</span>         indexReader.close();</span><br><span class="line"><span class="number">38</span>     &#125;</span><br><span class="line"><span class="number">39</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="NumericRangeQuery"><a href="#NumericRangeQuery" class="headerlink" title="　　NumericRangeQuery"></a>　　NumericRangeQuery</h3><p>　　可以根据数值范围查询。</p>
<p>　　<strong>具体代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数值范围查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNumericRangeQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Directory对象，指定索引库存放的路径</span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line">    <span class="comment">//创建IndexReader对象，需要指定Directory对象</span></span><br><span class="line">    IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line">    <span class="comment">//创建Indexsearcher对象，需要指定IndexReader对象</span></span><br><span class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建查询</span></span><br><span class="line">    <span class="comment">//参数：</span></span><br><span class="line">    <span class="comment">//1.域名</span></span><br><span class="line">    <span class="comment">//2.最小值</span></span><br><span class="line">    <span class="comment">//3.最大值</span></span><br><span class="line">    <span class="comment">//4.是否包含最小值</span></span><br><span class="line">    <span class="comment">//5.是否包含最大值</span></span><br><span class="line">    Query query = NumericRangeQuery.newLongRange(<span class="string">"fileSize"</span>, <span class="number">41L</span>, <span class="number">2055L</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个参数是查询对象，第二个参数是查询结果返回的最大值</span></span><br><span class="line">    TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询结果的总条数</span></span><br><span class="line">    System.out.println(<span class="string">"查询结果的总条数："</span>+ topDocs.totalHits);</span><br><span class="line">    <span class="comment">//遍历查询结果</span></span><br><span class="line">    <span class="comment">//topDocs.scoreDocs存储了document对象的id</span></span><br><span class="line">    <span class="comment">//ScoreDoc[] scoreDocs = topDocs.scoreDocs;</span></span><br><span class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line">        <span class="comment">//scoreDoc.doc属性就是document对象的id</span></span><br><span class="line">        <span class="comment">//int doc = scoreDoc.doc;</span></span><br><span class="line">        <span class="comment">//根据document的id找到document对象</span></span><br><span class="line">        Document document = indexSearcher.doc(scoreDoc.doc);</span><br><span class="line">        <span class="comment">//文件名称</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileName"</span>));</span><br><span class="line">        <span class="comment">//文件内容</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileContent"</span>));</span><br><span class="line">        <span class="comment">//文件大小</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileSize"</span>));</span><br><span class="line">        <span class="comment">//文件路径</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"filePath"</span>));</span><br><span class="line">        System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭indexreader对象</span></span><br><span class="line">    indexReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BooleanQuery"><a href="#BooleanQuery" class="headerlink" title="　　BooleanQuery"></a>　　BooleanQuery</h3><p>　　可以组合查询条件。</p>
<p>　　<strong>具体代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合条件查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBooleanQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Directory对象，指定索引库存放的路径</span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line">    <span class="comment">//创建IndexReader对象，需要指定Directory对象</span></span><br><span class="line">    IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line">    <span class="comment">//创建Indexsearcher对象，需要指定IndexReader对象</span></span><br><span class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个布尔查询对象</span></span><br><span class="line">    BooleanQuery query = <span class="keyword">new</span> BooleanQuery();</span><br><span class="line">    <span class="comment">//创建第一个查询条件</span></span><br><span class="line">    Query query1 = <span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"fileName"</span>, <span class="string">"apache"</span>));</span><br><span class="line">    Query query2 = <span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"fileName"</span>, <span class="string">"lucene"</span>));</span><br><span class="line">    <span class="comment">//组合查询条件</span></span><br><span class="line">    query.add(query1, Occur.MUST);</span><br><span class="line">    query.add(query2, Occur.MUST);</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个参数是查询对象，第二个参数是查询结果返回的最大值</span></span><br><span class="line">    TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询结果的总条数</span></span><br><span class="line">    System.out.println(<span class="string">"查询结果的总条数："</span>+ topDocs.totalHits);</span><br><span class="line">    <span class="comment">//遍历查询结果</span></span><br><span class="line">    <span class="comment">//topDocs.scoreDocs存储了document对象的id</span></span><br><span class="line">    <span class="comment">//ScoreDoc[] scoreDocs = topDocs.scoreDocs;</span></span><br><span class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line">        <span class="comment">//scoreDoc.doc属性就是document对象的id</span></span><br><span class="line">        <span class="comment">//int doc = scoreDoc.doc;</span></span><br><span class="line">        <span class="comment">//根据document的id找到document对象</span></span><br><span class="line">        Document document = indexSearcher.doc(scoreDoc.doc);</span><br><span class="line">        <span class="comment">//文件名称</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileName"</span>));</span><br><span class="line">        <span class="comment">//文件内容</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileContent"</span>));</span><br><span class="line">        <span class="comment">//文件大小</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileSize"</span>));</span><br><span class="line">        <span class="comment">//文件路径</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"filePath"</span>));</span><br><span class="line">        System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭indexreader对象</span></span><br><span class="line">    indexReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　Occur.MUST：必须满足此条件，相当于and</p>
<p>　　Occur.SHOULD：应该满足，但是不满足也可以，相当于or</p>
<p>　　Occur.MUST_NOT：必须不满足。相当于not</p>
<p>　　接着，演示第二种方法：<strong>使用queryparser查询</strong></p>
<p>　　通过QueryParser也可以创建Query，QueryParser提供一个Parse方法，此方法可以直接根据查询语法来查询。Query对象执行的查询语法可通过System.out.println(query);查询。</p>
<p>　　这个操作需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。</p>
<p>　　<strong>queryparser</strong></p>
<p>　　**具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryParser</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Directory对象，指定索引库存放的路径</span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line">    <span class="comment">//创建IndexReader对象，需要指定Directory对象</span></span><br><span class="line">    IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line">    <span class="comment">//创建Indexsearcher对象，需要指定IndexReader对象</span></span><br><span class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建queryparser对象</span></span><br><span class="line">    <span class="comment">//第一个参数默认搜索的域</span></span><br><span class="line">    <span class="comment">//第二个参数就是分析器对象</span></span><br><span class="line">    QueryParser queryParser = <span class="keyword">new</span> QueryParser(<span class="string">"fileName"</span>, <span class="keyword">new</span> IKAnalyzer());</span><br><span class="line">    <span class="comment">//使用默认的域,这里用的是语法，下面会详细讲解一下</span></span><br><span class="line">    Query query = queryParser.parse(<span class="string">"apache"</span>);</span><br><span class="line">    <span class="comment">//不使用默认的域，可以自己指定域</span></span><br><span class="line">    <span class="comment">//Query query = queryParser.parse("fileContent:apache");</span></span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个参数是查询对象，第二个参数是查询结果返回的最大值</span></span><br><span class="line">    TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询结果的总条数</span></span><br><span class="line">    System.out.println(<span class="string">"查询结果的总条数："</span>+ topDocs.totalHits);</span><br><span class="line">    <span class="comment">//遍历查询结果</span></span><br><span class="line">    <span class="comment">//topDocs.scoreDocs存储了document对象的id</span></span><br><span class="line">    <span class="comment">//ScoreDoc[] scoreDocs = topDocs.scoreDocs;</span></span><br><span class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line">        <span class="comment">//scoreDoc.doc属性就是document对象的id</span></span><br><span class="line">        <span class="comment">//int doc = scoreDoc.doc;</span></span><br><span class="line">        <span class="comment">//根据document的id找到document对象</span></span><br><span class="line">        Document document = indexSearcher.doc(scoreDoc.doc);</span><br><span class="line">        <span class="comment">//文件名称</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileName"</span>));</span><br><span class="line">        <span class="comment">//文件内容</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileContent"</span>));</span><br><span class="line">        <span class="comment">//文件大小</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"fileSize"</span>));</span><br><span class="line">        <span class="comment">//文件路径</span></span><br><span class="line">        System.out.println(document.get(<span class="string">"filePath"</span>));</span><br><span class="line">        System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭indexreader对象</span></span><br><span class="line">    indexReader.close();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询语法"><a href="#查询语法" class="headerlink" title="　　查询语法"></a>　　查询语法</h4><p>　　1、基础的查询语法，关键词查询：</p>
<p>　　　　域名+“：”+搜索的关键字</p>
<p>　　　　例如：content:java</p>
<p>　　2、范围查询</p>
<p>　　　　域名+“:”+[最小值 TO 最大值]</p>
<p>　　　　例如：size:[1 TO 1000]</p>
<p>　　　　范围查询在lucene中支持数值类型，不支持字符串类型。在solr中支持字符串类型。</p>
<p>　　3、组合条件查询</p>
<p>　　　　1）+条件1 +条件2：两个条件之间是并且的关系and</p>
<p>　　　　　　例如：+filename:apache +content:apache</p>
<p>　　　　2）+条件1 条件2：必须满足第一个条件，应该满足第二个条件</p>
<p>　　　　　　例如：+filename:apache content:apache</p>
<p>　　　　3）条件1 条件2：两个条件满足其一即可。</p>
<p>　　　　　　例如：filename:apache content:apache</p>
<p>　　　　4）-条件1 条件2：必须不满足条件1，要满足条件2</p>
<p>　　　　　　例如：-filename:apache content:apache</p>
<table>
<thead>
<tr>
<th>Occur.MUST 查询条件必须满足，相当于and</th>
<th>+（加号）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Occur.SHOULD 查询条件可选，相当于or</td>
<td>空（不用符号）</td>
</tr>
<tr>
<td>Occur.MUST_NOT 查询条件不能满足，相当于not非</td>
<td>-（减号）</td>
</tr>
</tbody>
</table>
<p>　　第二种写法：</p>
<p>　　条件1 AND 条件2</p>
<p>　　条件1 OR 条件2</p>
<p>　　条件1 NOT 条件2</p>
<h3 id="MultiFieldQueryParser"><a href="#MultiFieldQueryParser" class="headerlink" title="　　MultiFieldQueryParser"></a>　　MultiFieldQueryParser</h3><p>　　可以指定多个默认搜索域</p>
<p>　　**具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>     <span class="meta">@Test</span></span><br><span class="line"> <span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultiFiledQueryParser</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> <span class="number">3</span>         <span class="comment">//创建一个Directory对象，指定索引库存放的路径</span></span><br><span class="line"> <span class="number">4</span>         Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line"> <span class="number">5</span>         <span class="comment">//创建IndexReader对象，需要指定Directory对象</span></span><br><span class="line"> <span class="number">6</span>         IndexReader indexReader = DirectoryReader.open(directory);</span><br><span class="line"> <span class="number">7</span>         <span class="comment">//创建Indexsearcher对象，需要指定IndexReader对象</span></span><br><span class="line"> <span class="number">8</span>         IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader);</span><br><span class="line"> <span class="number">9</span>         </span><br><span class="line"><span class="number">10</span>         <span class="comment">//可以指定默认搜索的域是多个</span></span><br><span class="line"><span class="number">11</span>         String[] fields = &#123;<span class="string">"fileName"</span>, <span class="string">"fileContent"</span>&#125;;</span><br><span class="line"><span class="number">12</span>         <span class="comment">//创建一个MulitFiledQueryParser对象</span></span><br><span class="line"><span class="number">13</span>         MultiFieldQueryParser queryParser = <span class="keyword">new</span> MultiFieldQueryParser(fields, <span class="keyword">new</span> IKAnalyzer());</span><br><span class="line"><span class="number">14</span>         Query query = queryParser.parse(<span class="string">"apache"</span>);</span><br><span class="line"><span class="number">15</span>         System.out.println(query);</span><br><span class="line"><span class="number">16</span>         <span class="comment">//执行查询</span></span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>         <span class="comment">//第一个参数是查询对象，第二个参数是查询结果返回的最大值</span></span><br><span class="line"><span class="number">20</span>         TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>);</span><br><span class="line"><span class="number">21</span>         </span><br><span class="line"><span class="number">22</span>         <span class="comment">//查询结果的总条数</span></span><br><span class="line"><span class="number">23</span>         System.out.println(<span class="string">"查询结果的总条数："</span>+ topDocs.totalHits);</span><br><span class="line"><span class="number">24</span>         <span class="comment">//遍历查询结果</span></span><br><span class="line"><span class="number">25</span>         <span class="comment">//topDocs.scoreDocs存储了document对象的id</span></span><br><span class="line"><span class="number">26</span>         <span class="comment">//ScoreDoc[] scoreDocs = topDocs.scoreDocs;</span></span><br><span class="line"><span class="number">27</span>         <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line"><span class="number">28</span>             <span class="comment">//scoreDoc.doc属性就是document对象的id</span></span><br><span class="line"><span class="number">29</span>             <span class="comment">//int doc = scoreDoc.doc;</span></span><br><span class="line"><span class="number">30</span>             <span class="comment">//根据document的id找到document对象</span></span><br><span class="line"><span class="number">31</span>             Document document = indexSearcher.doc(scoreDoc.doc);</span><br><span class="line"><span class="number">32</span>             <span class="comment">//文件名称</span></span><br><span class="line"><span class="number">33</span>             System.out.println(document.get(<span class="string">"fileName"</span>));</span><br><span class="line"><span class="number">34</span>             <span class="comment">//文件内容</span></span><br><span class="line"><span class="number">35</span>             System.out.println(document.get(<span class="string">"fileContent"</span>));</span><br><span class="line"><span class="number">36</span>             <span class="comment">//文件大小</span></span><br><span class="line"><span class="number">37</span>             System.out.println(document.get(<span class="string">"fileSize"</span>));</span><br><span class="line"><span class="number">38</span>             <span class="comment">//文件路径</span></span><br><span class="line"><span class="number">39</span>             System.out.println(document.get(<span class="string">"filePath"</span>));</span><br><span class="line"><span class="number">40</span>             System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line"><span class="number">41</span>         &#125;</span><br><span class="line"><span class="number">42</span>         <span class="comment">//关闭indexreader对象</span></span><br><span class="line"><span class="number">43</span>         indexReader.close();</span><br><span class="line"><span class="number">44</span>     &#125;</span><br></pre></td></tr></table></figure>
<h2 id="IndexSearcher搜索方法"><a href="#IndexSearcher搜索方法" class="headerlink" title="IndexSearcher搜索方法"></a>IndexSearcher搜索方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>indexSearcher.search(query, n)</td>
<td>根据Query搜索，返回评分最高的n条记录</td>
</tr>
<tr>
<td>indexSearcher.search(query, filter, n)</td>
<td>根据Query搜索，添加过滤策略，返回评分最高的n条记录</td>
</tr>
<tr>
<td>indexSearcher.search(query, n, sort)</td>
<td>根据Query搜索，添加排序策略，返回评分最高的n条记录</td>
</tr>
<tr>
<td>indexSearcher.search(booleanQuery, filter, n, sort)</td>
<td>根据Query搜索，添加过滤策略，添加排序策略，返回评分最高的n条记录</td>
</tr>
</tbody>
</table>
<h2 id="TopDocs"><a href="#TopDocs" class="headerlink" title="　　TopDocs"></a>　　TopDocs</h2><p>　　Lucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下：</p>
<table>
<thead>
<tr>
<th>方法或属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>totalHits</td>
<td>匹配搜索条件的总记录数</td>
</tr>
<tr>
<td>scoreDocs</td>
<td>顶部匹配记录</td>
</tr>
</tbody>
</table>
<blockquote>
<p>　　注意：</p>
<p>　　　　（1）Search方法需要指定匹配记录数量n：indexSearcher.search(query, n)</p>
<p>　　　　（2）TopDocs.totalHits：是匹配索引库中所有记录的数量</p>
<p>　　　　（3）TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n</p>
</blockquote>
<p>　　</p>
<p>　　<strong>中文分词器 ：</strong></p>
<p>　　首先，看一看Lucene自带的中文分词器</p>
<p>　　（1）<strong>StandardAnalyzer</strong>：（标准分词器，也是前面例子中使用的分词器）</p>
<p>　　　　单字分词：就是按照中文一个字一个字地进行分词。</p>
<p>　　　　如：“我爱中国”，<br>　　　　效果：“我”、“爱”、“中”、“国”。</p>
<p>　　（2）<strong>CJKAnalyzer</strong></p>
<p>　　　　二分法分词：按两个字进行切分。</p>
<p>　　　　如：“我是中国人”，</p>
<p>　　　　效果：“我是”、“是中”、“中国”“国人”。</p>
<p>　　<strong>但上边两个分词器无法满足需求。</strong></p>
<p>　　（3）SmartChineseAnalyzer</p>
<p>　　　　对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理</p>
<p>　　然后，看一看我们开发真正使用的<strong>第三方中文分词器：</strong></p>
<p>　　我们今天介绍<strong>IK-analyzer</strong>这款第三方中文分词器</p>
<p>　　<a href="https://code.google.com/p/ik-analyzer/" target="_blank" rel="noopener">IK-analyzer</a>，支持Lucene 4.10从2006年12月推出1.0版开始，IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开 始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词 歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 但是也就是2012年12月后没有再更新。　</p>
<p>　　<strong>使用方法：</strong></p>
<p>　　第一步：把jar包添加到工程中</p>
<p>　　第二步：把<strong>配置文件</strong>和<strong>扩展词词典</strong>和<strong>停用词词典</strong>添加到classpath下（停用词词典与扩展词词典名称可自行定义，只要在配置文件中配置好就可以了）</p>
<p><img src="/images/lucene/dic.png" alt></p>
<p>注意：<strong>扩展词词典</strong>和<strong>停用词词典</strong>文件的格式为UTF-8，注意是<strong>无BOM 的UTF-8 编码</strong>。</p>
<p>　　配置文件详情</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"ext_dict"</span>&gt;</span>ext.dic;<span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"ext_stopwords"</span>&gt;</span>stopword.dic;<span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，创建分析器时，用一下代码就好了:<code>Analyzer analyzer = new IKAnalyzer();</code></p>
<p>　　<strong>注意：搜索使用的分析器要和索引使用的分析器一致，不然搜索出来结果可能会错乱。</strong></p>
<h2 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="　　3. 删除索引"></a>　　3. 删除索引</h2><p>（1）删除全部索引</p>
<p>　　说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复。<strong>此方法慎用！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>     <span class="comment">//删除全部索引</span></span><br><span class="line"> <span class="number">2</span>     <span class="meta">@Test</span></span><br><span class="line"> <span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteAllIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> <span class="number">4</span>         Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line"> <span class="number">5</span>         Analyzer analyzer = <span class="keyword">new</span> IKAnalyzer();</span><br><span class="line"> <span class="number">6</span>         IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(Version.LATEST, analyzer);</span><br><span class="line"> <span class="number">7</span>         IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, config);</span><br><span class="line"> <span class="number">8</span>         <span class="comment">//删除全部索引</span></span><br><span class="line"> <span class="number">9</span>         indexWriter.deleteAll();</span><br><span class="line"><span class="number">10</span>         <span class="comment">//关闭indexwriter</span></span><br><span class="line"><span class="number">11</span>         indexWriter.close();</span><br><span class="line"><span class="number">12</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>　　（2）指定查询条件删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据查询条件删除索引</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndexByQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line">    Analyzer analyzer = <span class="keyword">new</span> IKAnalyzer();</span><br><span class="line">    IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(Version.LATEST, analyzer);</span><br><span class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, config);</span><br><span class="line">    <span class="comment">//创建一个查询条件</span></span><br><span class="line">    Query query = <span class="keyword">new</span> TermQuery(<span class="keyword">new</span> Term(<span class="string">"fileContent"</span>, <span class="string">"apache"</span>));</span><br><span class="line">    <span class="comment">//根据查询条件删除</span></span><br><span class="line">    indexWriter.deleteDocuments(query);</span><br><span class="line">    <span class="comment">//关闭indexwriter</span></span><br><span class="line">    indexWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-索引库的修改"><a href="#4-索引库的修改" class="headerlink" title="　　4 索引库的修改"></a>　　4 索引库的修改</h2><p>　　更新的原理就是先删除在添加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改索引库</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">"E:\\programme\\test"</span>));</span><br><span class="line">    Analyzer analyzer = <span class="keyword">new</span> IKAnalyzer();</span><br><span class="line">    IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(Version.LATEST, analyzer);</span><br><span class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, config);</span><br><span class="line">    <span class="comment">//创建一个Document对象</span></span><br><span class="line">    Document document = <span class="keyword">new</span> Document();</span><br><span class="line">    <span class="comment">//向document对象中添加域。</span></span><br><span class="line">    <span class="comment">//不同的document可以有不同的域，同一个document可以有相同的域。</span></span><br><span class="line">    document.add(<span class="keyword">new</span> TextField(<span class="string">"fileXXX"</span>, <span class="string">"要更新的文档"</span>, Store.YES));</span><br><span class="line">    document.add(<span class="keyword">new</span> TextField(<span class="string">"contentYYY"</span>, <span class="string">"简介 Lucene 是一个基于 Java 的全文信息检索工具包。"</span>, Store.YES));</span><br><span class="line">    indexWriter.updateDocument(<span class="keyword">new</span> Term(<span class="string">"fileName"</span>, <span class="string">"apache"</span>), document);</span><br><span class="line">    <span class="comment">//关闭indexWriter</span></span><br><span class="line">    indexWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　　这样，Lucene的简单介绍使用就完成了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/maven_learn_2_20190221/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/maven_learn_2_20190221/" itemprop="url">Maven学习（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T14:30:30+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Maven学习过程（二）"><a href="#Maven学习过程（二）" class="headerlink" title="Maven学习过程（二）"></a>Maven学习过程（二）</h1><p><img src="/images/maven/logo.png" alt="logo"></p>
<h2 id="快速构建Java项目"><a href="#快速构建Java项目" class="headerlink" title="快速构建Java项目"></a>快速构建Java项目</h2><p>Maven 使用 archetype(原型) 来创建自定义的项目结构，形成 Maven 项目模板。</p>
<blockquote>
<p>在命令窗口使用<code>mvn archetype:generate</code>命令，按下enter键不断进行下一步的操作，直到创建成功。</p>
</blockquote>
<p>普通的maven项目，可以使用<code>maven-archetype-quickstart</code>插件创建maven项目：</p>
<p>这里我们直接一次写好所有的配置，其他使用默认值：</p>
<blockquote>
<p>mvn archetype:generate -DgroupId=com.companyname.bank -DartifactId=consumerBanking -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</p>
</blockquote>
<p>生成的项目结构如图：</p>
<p><img src="/images/maven/projectDir.png" alt></p>
<p>可知默认情况下Maven已经添加了一个源码文件<strong>comsumerBanking\src\main\java\com\companyname\bank\App.java</strong>和一个测试文件<strong>comsumerBanking\src\main\test\com\companyname\bank\AppTest.java</strong>；同样，查看<strong>pom.xml</strong>文件，会自带依赖<strong>junit</strong>。</p>
<p>文件说明：</p>
<table>
<thead>
<tr>
<th>文件夹结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>consumerBanking</td>
<td>包含 src 文件夹和 pom.xml</td>
</tr>
<tr>
<td>src/main/java contains</td>
<td>java 代码文件在包结构下（com/companyname/bank）。</td>
</tr>
<tr>
<td>src/main/test contains</td>
<td>测试代码文件在包结构下（com/companyname/bank）。</td>
</tr>
<tr>
<td>src/main/resources</td>
<td>包含了 图片 / 属性 文件（在上面的例子中，我们需要手动创建这个结构）。</td>
</tr>
</tbody>
</table>
<h2 id="Maven引入外部依赖"><a href="#Maven引入外部依赖" class="headerlink" title="Maven引入外部依赖"></a>Maven引入外部依赖</h2><p><strong>如果我们需要引入第三库文件到项目，该怎么操作呢？</strong></p>
<p>pom.xml 的 dependencies 列表列出了我们的项目需要构建的所有外部依赖项。</p>
<p>要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。如：我们添加一个 ldapjdk.jar ，它是为 LDAP 操作的一个帮助库，加入到lib文件夹后，在<strong>pom.xml</strong>里面添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里添加你的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!-- 库名称，也可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="comment">&lt;!--库名称，也可以自定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!--作用域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span> <span class="comment">&lt;!--项目根目录下的lib文件夹下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips：maven项目的依赖可以传递，如果父项目已经绑定了依赖，不需要再添加依赖。</p>
</blockquote>
<h2 id="Maven项目文档"><a href="#Maven项目文档" class="headerlink" title="Maven项目文档"></a>Maven项目文档</h2><p>此时，新鲜出炉的maven项目需要在<strong>pom.xml</strong>文件添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>不然运行</em> <strong><em>mvn site</em></strong> <em>命令时出现</em> <strong>java.lang.NoClassDefFoundError: org/apache/maven/doxia/siterenderer/DocumentContent</strong> <em>的问题， 这是由于 maven-site-plugin 版本过低，升级到 3.3+ 即可。</em></p>
</blockquote>
<p>此时再运行mvn site命令执行完成后，可以在<strong><em>consumerBanking\target\site</em></strong>文件夹中打开<strong><em>index.html</em></strong>文件查看项目文档。</p>
<h2 id="Maven自动化部署"><a href="#Maven自动化部署" class="headerlink" title="Maven自动化部署"></a>Maven自动化部署</h2><blockquote>
<p>一般的项目开发部署过程：</p>
<ul>
<li>每个团队将所有的项目代码提交到 SVN 或者代码库中并打上标签。</li>
<li>从 SVN 上下载完整的源代码。</li>
<li>构建应用。</li>
<li>存储构建输出的 WAR 或者 EAR 文件到一个常用的网络位置下。</li>
<li>从网络上获取文件并且部署文件到生产站点上。</li>
<li>更新文档并且更新应用的版本号。</li>
</ul>
</blockquote>
<p>其中涉及多个团队，很容易出错，maven可以结合如下方案实现自动化部署：</p>
<ul>
<li>使用 Maven 构建和发布项目</li>
<li>使用 SubVersion， 源码仓库来管理源代码</li>
<li>使用远程仓库管理软件（Jfrog或者Nexus） 来管理项目二进制文件。</li>
</ul>
<p>具体使用可以查看<a href="http://www.runoob.com/maven/maven-deployment-automation.html" target="_blank" rel="noopener">菜鸟教程Maven自动化部署</a>。</p>
<h2 id="使用Maven创建Web项目"><a href="#使用Maven创建Web项目" class="headerlink" title="使用Maven创建Web项目"></a>使用Maven创建Web项目</h2><p>这次我们使用<code>maven-archetype-webapp</code>插件，执行如下命令：</p>
<blockquote>
<p>mvn archetype:generate -DgroupId=com.companyname.automobile -DartifactId=trucks -DarchetypeArtifactId=maven-archetype-webapp  -DinteractiveMode=false</p>
</blockquote>
<p>完成后看到项目结构：</p>
<p><img src="/images/maven/webprojectDir.png" alt="maven web项目"></p>
<p>Maven 目录结构是标准的，各个目录作用如下表所示:</p>
<table>
<thead>
<tr>
<th>文件夹结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>trucks(即项目文件夹)</td>
<td>包含 src 文件夹和 pom.xml 文件。</td>
</tr>
<tr>
<td>src/main/webapp</td>
<td>包含 index.jsp 文件和 WEB-INF 文件夹.</td>
</tr>
<tr>
<td>src/main/webapp/WEB-INF</td>
<td>包含 web.xml 文件</td>
</tr>
<tr>
<td>src/main/resources</td>
<td>包含图片、properties资源文件。</td>
</tr>
</tbody>
</table>
<p><strong><em>pom.xml</em></strong>的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.automobile<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trucks<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>trucks Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>trucks<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同理在<strong>trucks</strong>目录下执行<code>mvn clean package</code>命令，构建项目成功后，找到<strong><em>\trucks\target\trucks.war</em></strong>，并复制到你的 web 服务器的 web 应用目录（本地的Tomcat服务器即可），然后重启 web 服务器，即可通过访问URL:<strong><em><a href="http://localhost:8080/trucks/index.jsp" target="_blank" rel="noopener">http://localhost:8080/trucks/index.jsp</a></em></strong>（比如我的tomcat服务器主机为localhost:8080）运行web应用。</p>
<blockquote>
<p>最后在这里加一个Maven在Eclipse下的使用: <a href="http://www.runoob.com/maven/maven-eclispe.html" target="_blank" rel="noopener">菜鸟教程之Maven Eclipse</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/blog_logo.jpg" alt="rookieChen">
            
              <p class="site-author-name" itemprop="name">rookieChen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rookieChen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
