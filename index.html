<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="RookieGuy Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="RookieGuy Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RookieGuy Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>RookieGuy Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/justOneRookie"><img style="position: absolute;top: 0;right: 0;border: 0;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RookieGuy Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">for better myself</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/jzOffer_3_20190306/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/jzOffer_3_20190306/" itemprop="url">剑指Offer刷题日记（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T00:00:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、斐波那契数列第n项"><a href="#一、斐波那契数列第n项" class="headerlink" title="一、斐波那契数列第n项"></a>一、斐波那契数列第n项</h1><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<p>n&lt;=39</p>
<p><strong>时间限制：1秒 空间限制：32768K</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自己的算法 咋一想，用递归，但是很慢，差点超时，真实too young too naive：</span></span><br><span class="line"><span class="comment">运行时间：967ms</span></span><br><span class="line"><span class="comment">占用内存：9224k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">于是想了想，优化算法如下：但是好像也是挺麻烦呀！</span></span><br><span class="line"><span class="comment">运行时间：14ms</span></span><br><span class="line"><span class="comment">占用内存：9312k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"n &lt; 0!"</span>);</span><br><span class="line">        <span class="keyword">int</span>[] x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        x[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        x[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            x[i%<span class="number">2</span>] = x[<span class="number">0</span>]+x[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x[n%<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以这样来：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            g += f;</span><br><span class="line">            f = g - f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、跳台阶"><a href="#二、跳台阶" class="headerlink" title="二、跳台阶"></a>二、跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p><strong>时间限制：1秒 空间限制：32768K</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自己的解法，</span></span><br><span class="line"><span class="comment">第一时间就是1+C(1,n-1)+C(2,n-2)+……+C(n/2, n-n/2)</span></span><br><span class="line"><span class="comment">但是有什么问题呢？阶乘数据过大，储存不了。</span></span><br><span class="line"><span class="comment">想了好久，最终受不了去看了论坛，自己还是太菜了呀！</span></span><br><span class="line"><span class="comment">原来，这还是斐波那契数列。</span></span><br><span class="line"><span class="comment">即第n阶只能由第n-1或者第n-2阶跳上来。</span></span><br><span class="line"><span class="comment">运行时间：14ms</span></span><br><span class="line"><span class="comment">占用内存：9392k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">1</span>,g=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(target&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            g+=f;</span><br><span class="line">            f=g-f;</span><br><span class="line">            target--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、变态跳台阶"><a href="#三、变态跳台阶" class="headerlink" title="三、变态跳台阶"></a>三、变态跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>时间限制：1秒 空间限制：32768K</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同理，青蛙可能从第0阶、第一阶..第n-1阶跳上来，故F(n) = F(n-1)+F(n-2)+...+F(0)= 2F(n-1)</span></span><br><span class="line"><span class="comment">这就很简单了，是等比数列。</span></span><br><span class="line"><span class="comment">运行时间：16ms</span></span><br><span class="line"><span class="comment">占用内存：9416k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，用位操作似乎比用Math.pow()好多了</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a&lt;&lt;(target-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/icbc_intertview_20190305/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/icbc_intertview_20190305/" itemprop="url">ICBC工行软件研发中心面试问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T00:00:00+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先是2分钟的自我介绍，我处理的并不好之前并没有充分的准备，条例不够清晰，也没有把重要的点说出来，hr要求看成绩单的时候还没有..对于项目只问了一点点，自己觉得的亮点是什么，遇到什么问题，很简单地提了一下，大概是因为我答的实在不好吧。难受呀老哥！</p>
<p>接下来看看问题吧：</p>
<h1 id="一、关于数据结构，对于排序算法有什么了解？归并算法的了解"><a href="#一、关于数据结构，对于排序算法有什么了解？归并算法的了解" class="headerlink" title="一、关于数据结构，对于排序算法有什么了解？归并算法的了解"></a>一、关于数据结构，对于排序算法有什么了解？归并算法的了解</h1><p>这个我主要回答了选择排序、插入排序、冒泡排序、快速排序、希尔排序、归并排序、堆排序、基数排序。</p>
<p>然后HR问了对于归并排序的了解，我回答的是把待排数组分为n组，两两归并，递归之..答得很不好，hr脸色都变了..</p>
<p>这是错误示范，正确的应该是：</p>
<blockquote>
<p>将两个的有序数列合并成一个有序数列，我们称之为”<strong>归并</strong>“。<br>归并排序(Merge Sort)就是利用归并思想对数列进行排序。根据具体的实现，归并排序包括”<strong>从上往下</strong>“和”<strong>从下往上</strong>“2种方式。这里主要说从下往上的思想：</p>
<p><strong>从下往上的归并排序</strong>：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)</p>
<p><img src="/images/interview/icbc_merge.jpg" alt></p>
</blockquote>
<h1 id="二、关于数据库，对于索引有什么了解，怎么存的？"><a href="#二、关于数据库，对于索引有什么了解，怎么存的？" class="headerlink" title="二、关于数据库，对于索引有什么了解，怎么存的？"></a>二、关于数据库，对于索引有什么了解，怎么存的？</h1><p>索引是用于加快检索速度、优化检索过程，提高查询效率的。</p>
<p>怎么存储的我回答了是用的倒排表，hr一脸懵逼，我就解释了一下倒排表是什么..现在想想，大概是要这样回答：</p>
<blockquote>
<p>索引有两种实现方式：</p>
<ol>
<li>Hash表</li>
<li>B+树，大多数据库引擎都使用B+树。B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可</li>
</ol>
</blockquote>
<h1 id="三、对面向对象、类和对象有什么了解？"><a href="#三、对面向对象、类和对象有什么了解？" class="headerlink" title="三、对面向对象、类和对象有什么了解？"></a>三、对面向对象、类和对象有什么了解？</h1><p>首先面向对象的定义：</p>
<blockquote>
<p> 一切事物皆对象，通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、继承，帮助人们实现对现实世界的抽象与数字建模。</p>
<p>我们知道，编写程序的目的是为了解决现实生活中的问题，编程的思维方式也应该贴近现实生活的思维方式。面向对象的编程方式就是为了实现上述目的而出现的。它使得编程工作更直观，更易理解。需要注意的是这里说的编程不光是coding还包括了设计的过程也是面向对象的</p>
<p>四个特征：</p>
<ul>
<li>抽象</li>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</blockquote>
<p>关于类和对象：</p>
<blockquote>
<p>类是抽象的，对象是具体的，是实例化的类。</p>
</blockquote>
<h1 id="四、对于Java的GC有什么了解？"><a href="#四、对于Java的GC有什么了解？" class="headerlink" title="四、对于Java的GC有什么了解？"></a>四、对于Java的GC有什么了解？</h1><p>这个问题对我来说有点难受，我刚开始看《深入理解JVM》。</p>
<p><strong>GC ：Garbage Collections</strong> 字面意思是垃圾回收器，释放垃圾占用的空间。</p>
<p>内存的分配是在JVM虚拟机的自动内存分配机制下完成的，所以我们现在来简单的了解一下JVM的内存管理结构：</p>
<p><img src alt></p>
<blockquote>
<p>JVM运行时数据区<br>①<strong>程序计数器(Program Counter Register)</strong>　　<br>    程序计数器是用于存储每个线程下一步将执行的JVM指令，如该方法为<code>native</code>的，则程序计数器中不存储任何信息</p>
<p>②<strong>JVM栈(JVM Stack)</strong>　　</p>
<p>​    JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：<code>boolean</code>、<code>char</code>、<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址</p>
<p>③<strong>堆(heap)</strong>　　</p>
<p>​    它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过<code>new</code>创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。　　</p>
<p>​    （1）堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了<code>new</code>对象的开销是比较大的　　</p>
<p>​    （<code>2</code>）Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配　　</p>
<p>​    （<code>3</code>）TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。</p>
<p><strong>④方法区（Method Area）</strong>　　</p>
<p>​    （<code>1</code>）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。　　</p>
<p>​    （<code>2</code>）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为<code>final</code>类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。</p>
<p><strong>⑤本地方法栈（Native Method Stacks）</strong>　　</p>
<p>​    JVM采用本地方法栈来支持<code>native</code>方法的执行，此区域用于存储每个<code>native</code>方法调用的状态。</p>
<p><strong>⑥运行时常量池（Runtime Constant Pool）</strong>　　</p>
<p>​    存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。JVM在加载类时会为每个<code>class</code>分配一个独立的常量池，但是运行时常量池中的字符串常量池是全局共享的。</p>
</blockquote>
<p>​    JVM将堆分成了二个大区<strong>新生代（Young）</strong>和<strong>老年代（Old）</strong>，新生代又被进一步划分为<strong>Eden和Survivor区</strong>，而Survivor由<strong>FromSpace和ToSpace</strong>组成，也有些人喜欢用<strong>Survivor1和Survivor2</strong>来代替。这里为什么要将Young划分为Eden、Survivor1、Survivor2这三块，给出的解释是　　</p>
<p>　　“Young中的98%的对象都是朝生夕死，所以将内存分为一块较大的Eden和两块较小的Survivor1、Survivor2，JVM默认分配是8:1:1，每次调用Eden和其中的Survivor1（FromSpace），当发生回收的时候，将Eden和Survivor1（FromSpace）存活的对象复制到Survivor2（ToSpace），然后直接清理掉Eden和Survivor1的空间。”</p>
<p>　　堆结构图如下：</p>
<p><img src="/images/interview/icbc_heap.png" alt></p>
<p>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。<br>　　老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。</p>
<p>　　新生代的GC（Minor GC）：新生代通常存活时间较短基于Copying算法进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到老年代。<strong>主要用Copying复制算法。</strong></p>
<p>　　老年代的GC（Major GC/Full GC）：老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此<strong>采用标记(Mark)算法来进行回收</strong>，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗。</p>
<p>更多的看<a href="https://www.cnblogs.com/wjtaigwh/p/6635484.html" target="_blank" rel="noopener">博客园阿呆哥哥的博客：Java–深入浅出GC自动回收机制</a></p>
<h1 id="五、Java的堆和栈的区别？"><a href="#五、Java的堆和栈的区别？" class="headerlink" title="五、Java的堆和栈的区别？"></a>五、Java的堆和栈的区别？</h1><blockquote>
<p>Java把内存划分成两种：一种是堆内存，一种是栈内存。</p>
<p>堆：主要用于存储实例化的对象，数组。由JVM动态分配内存空间。一个JVM只有一个堆内存，线程是可以共享数据的。</p>
<p>栈：主要用于存储局部变量和对象的引用变量，每个线程都会有一个独立的栈空间，所以线程之间是不共享数据的。</p>
<p>堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p>
</blockquote>
<ol>
<li><p>各司其职<br>最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>
</li>
<li><p>独有还是共享<br>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>
</li>
<li><p>异常错误<br>如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。<br>而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</p>
</li>
<li><p>空间大小<br>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快 就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。</p>
<p>你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。</p>
</li>
</ol>
<p>这里主要参考<a href="https://blog.csdn.net/qq_41675686/article/details/80400775" target="_blank" rel="noopener">CSDN月吖吖：Java堆和栈的区别，JVM堆和栈的介绍</a>.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/jzOffer_2_20190304/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/jzOffer_2_20190304/" itemprop="url">剑指Offer刷题日记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T00:00:00+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、重建二叉树"><a href="#一、重建二叉树" class="headerlink" title="一、重建二叉树"></a>一、重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><strong>时间限制：1秒 空间限制：32768K </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">自己的渣渣算法</span></span><br><span class="line"><span class="comment">运行时间：199ms</span></span><br><span class="line"><span class="comment">占用内存：23180k  差点不够用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span></span>&#123;</span><br><span class="line">        TreeNode r = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n =in.length;</span><br><span class="line">        <span class="comment">//如果长度不为1，则说明不是叶节点，还要继续重建</span></span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//处理左子树</span></span><br><span class="line">            <span class="keyword">int</span> numOfLeft=<span class="number">0</span>;  <span class="comment">//根的左边有多少结点</span></span><br><span class="line">            <span class="keyword">while</span>(in[numOfLeft]!=pre[<span class="number">0</span>]) numOfLeft++;</span><br><span class="line">            <span class="comment">//如果有左子树，对左子树进行递归的重建</span></span><br><span class="line">            <span class="keyword">if</span>(numOfLeft != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> []newPre = <span class="keyword">new</span> <span class="keyword">int</span>[numOfLeft];</span><br><span class="line">                <span class="keyword">int</span> []newIn = <span class="keyword">new</span> <span class="keyword">int</span>[numOfLeft];</span><br><span class="line">                System.arraycopy(pre,<span class="number">1</span>, newPre, <span class="number">0</span> ,numOfLeft);</span><br><span class="line">                System.arraycopy(in,<span class="number">0</span>, newIn, <span class="number">0</span> ,numOfLeft);</span><br><span class="line">                r.left = reConstructBinaryTree(newPre, newIn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> r.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//处理右子树，同理。</span></span><br><span class="line">            <span class="keyword">if</span>(n-numOfLeft-<span class="number">1</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                r.right =<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n-numOfLeft-<span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                r.right = <span class="keyword">new</span> TreeNode(in[numOfLeft+<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> []newPre2 = <span class="keyword">new</span> <span class="keyword">int</span>[n-numOfLeft-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> []newIn2 = <span class="keyword">new</span> <span class="keyword">int</span>[n-numOfLeft-<span class="number">1</span>];</span><br><span class="line">                System.arraycopy(pre, numOfLeft+<span class="number">1</span>, newPre2, <span class="number">0</span>, n-numOfLeft-<span class="number">1</span>);</span><br><span class="line">                System.arraycopy(in, numOfLeft+<span class="number">1</span>, newIn2, <span class="number">0</span>, n-numOfLeft-<span class="number">1</span>);</span><br><span class="line">                r.right = reConstructBinaryTree(newPre2, newIn2);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r.left = <span class="keyword">null</span>;</span><br><span class="line">            r.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大牛也是使用同样的思想，但是大牛的处理显然比我的好太多太多..</p>
<p>(但是运行时空似乎相差不大..)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">链接：https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6</span></span><br><span class="line"><span class="comment">来源：牛客网</span></span><br><span class="line"><span class="comment">运行时间：282ms</span></span><br><span class="line"><span class="comment">占用内存：23068k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        TreeNode root=reConstructBinaryTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(startPre&gt;endPre||startIn&gt;endIn)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIn;i&lt;=endIn;i++)</span><br><span class="line">            <span class="keyword">if</span>(in[i]==pre[startPre])&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(pre,startPre+<span class="number">1</span>,startPre+i-startIn,in,startIn,i-<span class="number">1</span>);</span><br><span class="line">                root.right=reConstructBinaryTree(pre,i-startIn+startPre+<span class="number">1</span>,endPre,in,i+<span class="number">1</span>,endIn);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、用两个栈实现队列"><a href="#二、用两个栈实现队列" class="headerlink" title="二、用两个栈实现队列"></a>二、用两个栈实现队列</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>时间限制：1秒 空间限制：32768K</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自己的算法</span></span><br><span class="line"><span class="comment">运行时间：13ms</span></span><br><span class="line"><span class="comment">占用内存：9532k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.add((Integer)node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack1.empty()&amp;&amp;stack2.empty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以stack1为基本存储，每次pop操作的时候，如果stack2为空，</span></span><br><span class="line">        <span class="comment">//就将stack1的内容全部放到stack2中再pop</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">                stack2.add(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、旋转数组的最小数字"><a href="#三、旋转数组的最小数字" class="headerlink" title="三、旋转数组的最小数字"></a>三、旋转数组的最小数字</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p><strong>时间限制：3秒 空间限制：32768K </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自己的算法   有人说用二分查找，但是如果是有重复元素的话二分法就不行了</span></span><br><span class="line"><span class="comment">运行时间：267ms</span></span><br><span class="line"><span class="comment">占用内存：27896k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[i+<span class="number">1</span>]) <span class="keyword">return</span> array[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/jzOffer_1_20190302/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/jzOffer_1_20190302/" itemprop="url">剑指offer刷题日记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T00:00:00+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、二维数组中的查找"><a href="#一、二维数组中的查找" class="headerlink" title="一、二维数组中的查找"></a>一、二维数组中的查找</h1><p><em>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</em></p>
<p><strong>时间限制：1秒 空间限制：32768K</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自己写的渣渣算法，从左上角开始</span></span><br><span class="line"><span class="comment">运行时间：212ms</span></span><br><span class="line"><span class="comment">占用内存：16584k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r_len = array[<span class="number">0</span>].length; <span class="comment">//一行的长度</span></span><br><span class="line">        <span class="keyword">int</span> c_len = array.length;  <span class="comment">//一列的长度</span></span><br><span class="line">	    <span class="keyword">if</span>(c_len==<span class="number">0</span> || r_len==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>][<span class="number">0</span>]&gt;target) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[c_len-<span class="number">1</span>][r_len-<span class="number">1</span>]&lt;target) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//找到大于等于target的第m行第n列的元素</span></span><br><span class="line">        <span class="keyword">while</span>(array[row][col]&lt;target &amp;&amp; col&lt;r_len-<span class="number">1</span>) col++;</span><br><span class="line">        <span class="keyword">while</span>(array[row][col]&lt;target &amp;&amp; row&lt;c_len-<span class="number">1</span>) row++;</span><br><span class="line">        <span class="comment">//如果找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(array[row][col]==target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[row][col]&gt;target &amp;&amp; col&gt;<span class="number">0</span>) col--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(array[row][col]&lt;target &amp;&amp; row&lt;c_len-<span class="number">1</span>) row++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(col==<span class="number">0</span> &amp;&amp; row==c_len-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(array[row][col]!=target) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑混乱，步骤多余，下面请看<a href="https://www.nowcoder.com/3478246" target="_blank" rel="noopener">牛客网</a>大牛的解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">牛客大牛的解法，从左下角开始。</span></span><br><span class="line"><span class="comment">运行时间：10ms</span></span><br><span class="line"><span class="comment">占用内存：1388k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rowCount = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> colCount = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=rowCount<span class="number">-1</span>,j=<span class="number">0</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;colCount;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == <span class="built_in">array</span>[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二、替换空格"><a href="#二、替换空格" class="headerlink" title="二、替换空格"></a>二、替换空格</h1><p><em>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</em></p>
<p><strong>时间限制：1秒 空间限制：32768K</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自己的渣渣解法，使用了replace()函数</span></span><br><span class="line"><span class="comment">运行时间：19ms</span></span><br><span class="line"><span class="comment">占用内存：9480k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> i=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            i=str.indexOf(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(i==-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            str.replace(i,i+<span class="number">1</span>,<span class="string">"%20"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不使用replace()函数：牛客网大大的解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">链接：https://www.nowcoder.com/questionTerminal/4060ac7e3e404ad1a894ef3e17650423</span></span><br><span class="line"><span class="comment">来源：牛客网</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题1：替换字符串，是在原来的字符串上做替换，还是新开辟一个字符串做替换！</span></span><br><span class="line"><span class="comment">问题2：在当前字符串替换，怎么替换才更有效率（不考虑java里现有的replace方法）。</span></span><br><span class="line"><span class="comment">      从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下</span></span><br><span class="line"><span class="comment">      从后往前，先计算需要多少空间，然后从后往前移动，则每个字符只为移动一次，这样效率更高一点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> spacenum = <span class="number">0</span>;<span class="comment">//spacenum为计算空格数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">                spacenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> indexold = str.length()-<span class="number">1</span>; <span class="comment">//indexold为为替换前的str下标</span></span><br><span class="line">        <span class="keyword">int</span> newlength = str.length() + spacenum*<span class="number">2</span>;<span class="comment">//计算空格转换成%20之后的str长度</span></span><br><span class="line">        <span class="keyword">int</span> indexnew = newlength-<span class="number">1</span>;<span class="comment">//indexold为为把空格替换为%20后的str下标</span></span><br><span class="line">        str.setLength(newlength);<span class="comment">//使str的长度扩大到转换成%20之后的长度,防止下标越界</span></span><br><span class="line">        <span class="keyword">for</span>(;indexold&gt;=<span class="number">0</span> &amp;&amp; indexold&lt;newlength;--indexold)&#123; </span><br><span class="line">                <span class="keyword">if</span>(str.charAt(indexold) == <span class="string">' '</span>)&#123;  <span class="comment">//</span></span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'%'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str.setCharAt(indexnew--, str.charAt(indexold));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、从尾到头打印链表"><a href="#三、从尾到头打印链表" class="headerlink" title="三、从尾到头打印链表"></a>三、从尾到头打印链表</h1><p><em>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</em></p>
<p><strong>时间限制：1秒 空间限制：32768K</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自己的渣渣解法，使用递归</span></span><br><span class="line"><span class="comment">运行时间：16ms</span></span><br><span class="line"><span class="comment">占用内存：9392k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getValue</span><span class="params">(ListNode i, ArrayList&lt;Integer&gt; a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        getValue(i.next, a);</span><br><span class="line">        a.add(i.val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        getValue(listNode, arrayList);</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>牛客大牛的解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时间：3ms</span></span><br><span class="line"><span class="comment">//占用内存：376k</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value.insert(value.begin(),head-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempVec = printListFromTailToHead(head-&gt;next);</span><br><span class="line">                <span class="keyword">if</span>(tempVec.size()&gt;<span class="number">0</span>)</span><br><span class="line">                value.insert(value.begin(),tempVec.begin(),tempVec.end());  </span><br><span class="line">            &#125;         </span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Linux_learn_1_20190301/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/01/Linux_learn_1_20190301/" itemprop="url">Linux学习日记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-01T00:00:00+08:00">
                2019-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="硬链接与软链接的区别"><a href="#硬链接与软链接的区别" class="headerlink" title="硬链接与软链接的区别"></a>硬链接与软链接的区别</h3><blockquote>
<p>硬链接：A、B两个链接指向同一个i节点，使用不同的文件名。即同一个i节点对应不同的引用。</p>
<p>软链接（符号链接）：A掌握着真正文件，B有自己的i节点，该节点只是存了一个指向A的文件的路径名。</p>
</blockquote>
<h3 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h3><blockquote>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul>
<li>当为[ <strong>d</strong> ]则是目录</li>
<li>当为[ <strong>-</strong> ]则是文件；</li>
<li>若是[ <strong>l</strong> ]则表示为链接文档(link file)；</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p>
<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r=4， w=2,x=1</li>
</ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
<p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  chmod [-R] xyz 文件或目录</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>选项与参数：</p>
<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
</blockquote>
<h3 id="inode和Block"><a href="#inode和Block" class="headerlink" title="inode和Block"></a>inode和Block</h3><blockquote>
<p>操作系统的文件数据除了文件实际内容外，还有非常多的属性，如文件权限（rwx）与文件属性（所有者、群组、时间参数等）。</p>
<p>文件系统通常<strong>将这两部分数据存放在不同的块</strong>。<strong>权限属性放到 inode 中,实际数据放到 data block 中。</strong></p>
<p>还有一个<strong>超级块（super block）</strong>会记录文件系统的整体信息，包括 inode 与block 的数量、使用量等。</p>
<ul>
<li>inode:记录文件属性，一个文件占用一个inode,同时记录此文件的数据所在的block号码；</li>
<li>block：实际记录文件的内容，若文件太大时会占用多个 block ；</li>
<li>super block：记录文件系统的整体信息，包括inode/block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等。</li>
</ul>
</blockquote>
<h3 id="grep和awk"><a href="#grep和awk" class="headerlink" title="grep和awk"></a>grep和awk</h3><blockquote>
<p>grep 主要用于搜索某些字符串，awk 用于处理文本 。</p>
<p>grep基本是以行为单位处理文本的； 而awk可以做更细分的处理，通过指定分隔符将一行（一条记录）划分为多个字段，以字段为单位处理文本。awk中支持C语法，可以有分支条件判断、循环语句等，相当于一个小型编程语言。<br>awk功能比较多是一个编程语言了。 grep功能简单，就是一个简单的正则表达式的匹配。 awk的功能依赖于grep。<br>grep可以理解为主要作用是在一个文件中查找过滤需要的内容。awk不是过滤查找，而是文本处理工具，是把一个文件处理成你想要的格式。</p>
</blockquote>
<h3 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h3><p>参考：<a href="https://blog.csdn.net/dream_1996/article/details/71001006" target="_blank" rel="noopener">csdn Cerry_Zjl的博文</a>.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/java_interview_20190227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/java_interview_20190227/" itemprop="url">Java面试小题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T00:00:00+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里记录一下Java面试的一些小题目，随心记录。</p>
<ul>
<li><p>java中，equals()和==的区别</p>
<blockquote>
<p>值类型是存储在内存中的堆栈（以后简称栈），而引用类型的变量在<strong>栈中仅仅是存储引用类型变量的地址</strong>，而其<strong>本身则存储在堆中</strong>。</p>
<p>==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量本身在<strong>堆中的地址</strong>是否相同，即<strong>栈中的内容</strong>是否相同（是否保存了同一个地址）。</p>
<p>​    equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。</p>
<p>​    ==比较的是2个对象的地址，而equals比较的是2个对象的内容。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>sleep()和wait()的区别</p>
<blockquote>
<p>sleep()是属于Thread类的。而wait()是Object类的。</p>
<p>sleep的线程不会施放对象锁，sleep导致了程序暂停执行，指定了时间，让出cpu，但是其监控状态仍然保持，到了指定的时间会恢复执行。</p>
<p>而wait()调用时会放弃对象锁，进入等待该对象的等待锁定池，只有针对该对象调用notify()方法后本线程才进入等待对象池等待。</p>
</blockquote>
</li>
</ul>
<p>主要看<a href="https://blog.csdn.net/u012073449/article/details/50986250" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: 阿里JAVA开发面试常问问题总结1</a></p>
<p><a href="https://blog.csdn.net/u012073449/article/details/50986782" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: 阿里JAVA开发面试常问问题总结2</a></p>
<p><a href="https://blog.csdn.net/u012073449/article/details/50990546" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: 阿里JAVA开发面试常问问题总结3</a></p>
<p><a href="https://blog.csdn.net/u012073449/article/details/50992348" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: 阿里JAVA开发面试常问问题总结4</a></p>
<p><a href="https://blog.csdn.net/u012073449/article/details/50975024" target="_blank" rel="noopener">CSDN ALice_yufeng的博客: Java中几个“区别”总结</a></p>
<p><a href="https://blog.csdn.net/andong154564667/article/details/80117546" target="_blank" rel="noopener">CSDN 东东咚咚咚咚咚丶的博客: 后端开发常问面试题集锦</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/sort_20190227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/sort_20190227/" itemprop="url">常用的一些简单排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T00:00:00+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思想：从某个方向两两相邻比较元素的值，若为逆序，则交换。每一轮冒泡完可以保证在第i个位置的元素是正确的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasSwap = <span class="keyword">false</span>; <span class="comment">//判断是否进行过交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;   </span><br><span class="line">             <span class="keyword">if</span>(a[j]&gt;a[j-<span class="number">1</span>])&#123;</span><br><span class="line">            	swap(a[j], a[j-<span class="number">1</span>]);</span><br><span class="line">            	hasSwap = <span class="keyword">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasSwap) <span class="keyword">break</span>;  <span class="comment">//如果一次交换都没有，则表示已经有序，直接结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>思想：依次将待排序的目标插入到已经排好序的序列里，直到所有的序列都排好序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i-<span class="number">1</span>]&lt;a[i])&#123;  <span class="comment">//如果待排元素比已排最小元素大，则需要进行排序</span></span><br><span class="line">            <span class="keyword">int</span> temp=a[i];  <span class="comment">//保存待排元素</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            	<span class="keyword">if</span>(a[j]&lt;temp)   <span class="comment">//如果这个位置比待排元素小，后移</span></span><br><span class="line">                    a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>；<span class="comment">//否则，表示找到了位置。</span></span><br><span class="line">        	&#125;</span><br><span class="line">            a[j+<span class="number">1</span>]=temp;<span class="comment">//插入到找到的合适的位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>思路：从无序区选择一个最大/最小的元素插入到有序区的最后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&gt;a[max])</span><br><span class="line">                max=j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i],a[max]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>思想：让序列基本有序，使用<strong>分组插入排序</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,gap,k;</span><br><span class="line">    <span class="keyword">for</span>(gap=len/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)&#123;  <span class="comment">//确定步长</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;gap;i++)&#123;  <span class="comment">//确定分组个数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(j=i+gap;j&lt;len;j=j+gap)&#123; <span class="comment">//对每个分组进行插入排序</span></span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;a[j-gap])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                    <span class="keyword">for</span>(k=j-gap;k&gt;=<span class="number">0</span>;k=k-gap)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(a[k]&lt;temp) a[k+gap]=a[k];</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k+gap]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>思想：分治法，将数组拆分为n个组排序，然后归并。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end, <span class="keyword">int</span> temp[])</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/java_learn_IOmodel_20190227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/java_learn_IOmodel_20190227/" itemprop="url">Java学习日记（二）：Java 网络IO模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T00:00:00+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考自<a href="https://blog.csdn.net/szxiaohe/article/details/81542605" target="_blank" rel="noopener">CSDN Simon格子的博文</a>。</p>
<p>这里本文杜撰了一个大嘴开饭店的故事，来类比Java IO模型的演变，帮助理解几种模型的功能和特点，IO分为磁盘IO和网络IO，本文讨论的都是网络IO。</p>
<p>爪哇村的大嘴做得一手好菜，原本是和平饭店的厨子，对吃的东西悟性很高，工作之余喜欢研究各种创新菜，最近自创一道麻辣小龙虾，顾客们吃后反响强烈，于是，大嘴想自立门户，专门开店经营小龙虾。</p>
<p>说干就干，为了方便抓虾，大嘴将饭店开在了河边，并取名“河底捞”。大嘴虽然姓大，但是野心其实并不大，起初，只是想采取日式料理的做法，店里就他自己一个人，晚上抓虾，白天做成麻辣小龙虾，服务客人。</p>
<p>计划赶不上变化，饭店开张没几天，来吃小龙虾的人越来越多，到饭点时间，大嘴一个人根本忙不过来，实在没办法，于是大嘴找到隔壁张三、李四和王五的老婆，对这3个人讲，到饭点时到他店里来帮忙，主要是帮他当服务员，负责给客人点餐，上菜，结账，清理桌子。大嘴说，来了客人，我就叫你们仨，服务完客人，你们各回各家。于是，我们的BIO通信模型登场了：</p>
<p><img src="/images/java_io_model/BIO.png" alt></p>
<p>来一个客人（Web Brower1），大嘴（Acceptor）就去隔壁叫张三（New Thread1），服务完客人，张三就回家。</p>
<p>来两个客人（Web Brower2），大嘴就去隔壁叫李四（New Thread2），服务完客人，李四就回家。</p>
<p>来三个客人（Web Brower3），大嘴就去隔壁叫王五的老婆（New Thread3），服务完客人，王五的老婆就回家。</p>
<p>经营理念就是<strong>一个服务员全程服务好一个客人（connection per thread）</strong>，客人上桌后，服务员就要站在旁边服务，直到客人用餐完毕。美味的小龙虾和良好的用餐体验，吸引越来越多的村民来大嘴店里用餐。随着客户端数量不断增加，BIO通信模型的问题显露无疑：<strong>每一个新客户端接入时，服务端必须创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接，在高性能服务领域，需要面对成千上万个客户端并发连接，这种模型无法满足高性能、高并发接入场景。</strong>采用这种模型，要想满足客人用餐需求，再多来一个客人，大嘴得临时叫上赵六，孙七，周八，吴九，郑十，大嘴能叫过来帮忙的邻居就这么几位，叫完就没有了。后面来的客人，大嘴只好让他们回家，改天再来。</p>
<p>这样下去显然不行，大嘴又找到隔壁张三、李四和王五的老婆，对这3个人讲：以后我不叫你们了，你们每天直接来我店里上班，换上“河底捞”的统一服装，朝九晚五，我给你们开固定工资，这样就节省了你们来来回回的时间，一开始张三和李四不是特别愿意，说要在家陪老婆，但是很快被王五的老婆说服了。<strong>于是有了采用线程池和任务队列的“伪异步IO模型”。</strong></p>
<p><strong>当有新客户端接入时，将客户端的Socket封装成一个Task，投递到后端线程池中进行处理，线程池维护一个消息队列和N个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，资源是可控的，无论多少个客户端并发访问，也不会导致资源耗尽和宕机。</strong></p>
<p><img src="/images/java_io_model/fake_io.png" alt></p>
<p>没客人时，张三、李四和王五的老婆都在店里待命，新来了客人，他们仨陆续上去服务，服务完，继续在店里待命，店门口放了5个凳子，供客人等候。这样改进之后，用户体验有了一定提升，但3个服务员在客人用餐时，还是全程陪在桌旁为其服务，用过餐的都夸“河底捞”的服务好。尤其是钱大爷，特别满意“河底捞”的服务，钱大爷爱喝酒，每次用餐要4个小时，王五的老婆在旁边一会上菜，一会倒酒，一会递热毛巾，基本上一天就服务钱大爷这一个客人。当钱大爷这类人来用餐时，外面排队的5个凳子早早就坐满了人，并且后面再来的客人，大嘴只能劝他们改日再来。</p>
<p>这就是这种“伪异步IO模型”典型的问题，<strong>当可用线程都被故障服务器阻塞时，后续所有的IO消息都将在队列中排队，线程池采用阻塞队列实现，当队列积满后，后续入队的操作将被阻塞，<em>前端只有一个Accept线程接收客户端接入，它被阻塞在线程池的同步阻塞队列之后，新的客户端请求将被拒绝，客户端会发生大量连接超时</em>。</strong></p>
<p>大嘴很快意识到，“伪异步IO模型”依然极大地限制了客流量，导致后面来的客人怨声载道，村里的林捕头每天下班过来，想要吃一顿小龙虾，发现门口已经排满了人，根本吃不上。林捕头放出风声，说大嘴长期在河边抓虾，可能会破坏村里的生态环境。于是大嘴紧急召集张三、李四和王五的老婆开会，讨论如何让林捕头能够排上队，吃上小龙虾。</p>
<p>张三曾经在爪哇村村委会干过一段时间码农，他说他知道有一种<strong>NIO模型（非阻塞IO）</strong>，和现在店里的情况很像。几乎所有的网络连接都会经过<strong>“读取请求内容—&gt;解码—&gt;计算处理—&gt;编码—&gt;回复”</strong>，类似于店里<strong>“接待—&gt;找桌—&gt;点菜—&gt;上菜—&gt;结账—&gt;收拾桌子”，每开一个桌子，我们称为开了一个channel，每个桌上放一个灯，当客人有点菜、上菜、结账等服务需求时，点亮灯，我们会有一个全局的管理者selector，会不断地在各个channel轮询（polling），检测是否有灯点亮，如果有灯亮，则通知专门的服务员来进行服务。这就是IO多路复用，IO多路复用可同时监听多个描述符（socket），一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，<em>IO多路复用避免阻塞在IO上，原本为多线程来接收多个连接的消息变为单线程保存多个socket的状态后轮询处理</em>。</strong></p>
<p><strong>这种机制也叫做反应器模式（Reactor），Reactor负责响应IO事件（accept，read，send），当检测到一个新的事件，将其发送给相应的Handler去处理。Reactor为单个线程，需要处理accept连接，同时发送请求到Handler中。由于只有单个线程，所以Handler中的业务需要能够快速处理完。</strong></p>
<p><img src="/images/java_io_model/reactor.png" alt></p>
<p>于是，大嘴安排张三专职点菜传菜，李四负责上菜结账，王五的老婆负责其他on call的特殊服务，大嘴则负责盯着各个桌上的灯是否亮着，有灯点亮就叫相应的服务员过来处理。这样改进后，效果显著，虽然饭店已经人满为患，门口竟然没有排队的，生意越来越红火。</p>
<p>改进流程后，服务效率显著提高，店里的客流量继续增长，三个服务员每天忙得不可开交，但对于来个十桌八桌客人，三个服务员基本可以轻松应付。不过在某些情况下，会突然出现人手急剧短缺的情况，这种情况在林捕头就餐时经常发生。林捕头有选择困难症，每次点菜时，要考虑半个小时，并且不让服务员离开，因为他有很多问题向服务员咨询。结账时，因为要拿去衙门报销，需要开发票，又需要服务员帮忙写发票抬头，打印，最后还不忘找服务员要停车票。</p>
<p><strong>这个问题正好就是NIO模型的缺点，这种模型由于IO在阻塞时会一直等待，因此在用户负载增加时，性能下降的非常快。server导致阻塞的原因有：</strong></p>
<p><strong>1、serversocket的accept方法，阻塞等待client连接，直到client连接成功。</strong></p>
<p><strong>2、线程从socket inputstream读入数据，会进入阻塞状态，直到全部数据读完。</strong></p>
<p><strong>3、线程向socket outputstream写入数据，会阻塞直到全部数据写完</strong></p>
<p>既然能发现缺点，就有相应的解决办法，聊过非阻塞IO后， 再来看看异步IO（AIO）。 IO方面的概念很多，阻塞性与异步性是其关键概念。简单而言，<strong>凡是需要由应用程序将数据读写到应用程序内存中的IO，都是同步IO，比如上面的BIO与NIO。相对的，凡是由OS来完成读写的，就是异步IO。</strong>这个说法有些迷惑，举例而言，<strong>在NIO中，当应用程序检测到某个Channel有可读数据时，必须显式发起一个read请求。而在异步IO中，应用程序仅仅需要告诉OS，我需要什么数据，并提供给OS一个Buffer和一个回调。OS会自己检测Channel的可读性，当发现其可读，会自动将数据复制到Buffer中，并通知应用程序任务完成。</strong>异步IO的典型实现是NodeJS。显然，由于将任务进一步下发到了OS，应用程序的可伸缩性及性能会大大增强。并且，比起非阻塞的NIO，异步IO编程更加容易一些, 性能也基本上总是优于它。</p>
<p>有了这一理论基础，可以继续讲大嘴的故事。</p>
<p>不到一年，小龙虾生意一发不可收拾，店里的营收越来越可观，王五的老婆也用上了iPhoneX和ipad pro，但王五的老婆一直想买一辆BMW，在得知ipad里面有很多点餐的APP后，她对大嘴说：其实咱们店只需要一个服务员就可以了，张三和李四完全是多余的，把他们俩的钱给我，我一个人可以服务所有客人。大嘴表示怀疑：咱们店一天接待几十桌客人，你一个人怎么忙得过来？</p>
<p>王五的老婆说，咱们店里所有的工作分为两类：</p>
<p>1.马上就能干完的，例如接待，找座，下单，清理桌子等</p>
<p>2.需要等别人干完才能干的活，比如点菜（需要顾客想好吃什么），上菜（需要后厨做好），结账（需要顾客确认账单、买单）等。</p>
<p>对于第1类工作，我马上干活，对于第2类工作，我也不会等待，我只要告诉别人，你弄完了告诉我一声，我会接着干，然后马上去做第1类工作。比如点菜，我只要给客人一个ipad，给完ipad我就立刻离开，客人点完餐后叫我，我只要点确认下单即可。结账时，我只要给客人一张带二维码的消费清单小票，我就立刻离开，客人确认完消费清单，自己扫描二维码进行支付，结账完毕后，叫我过来确认即可，我顺便把桌子打扫了，如果顾客需要发票，可以去前台凭小票自助打印，不需要服务员参与。</p>
<p>王五的老婆说的这一套，正是jdk7引入的NIO2模型，又叫异步IO（AIO）。为了说明异步IO，用计算机视角再回顾一下店里的服务流程：</p>
<p><strong>服务员：线程</strong></p>
<p><strong>顾客：http请求</strong></p>
<p><strong>后厨做菜，客人吃饭：耗时的IO操作</strong></p>
<p><strong>后厨大喊一声上菜：这是一个长时间IO操作完成后所发出的事件</strong></p>
<p><strong>客人说结账：另外一个长时间IO操作完成后所发出的事件</strong></p>
<p>第一类工作(迎客，找座，下单) : 在服务器端的业务逻辑代码，能够快速执行。</p>
<p>第二类工作(上菜，结账) : 同样是能快速执行的代码，但是他们需要等待那些耗时的IO 操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在AIO中实际上是在回调函数中来执行的：</p>
<p>下面是AIO服务模式的伪代码：</p>
<p><img src="/images/java_io_model/AIO.png" alt></p>
<p>后厨处理（）这个函数接受两个参数，一个是事件名，另外一个是匿名的回调函数，事件发生，回调函数才会执行。客人吃饭（）函数也是类似。</p>
<p>王五的老婆接着说，我的秘诀就是不等待，耗时的操作全部使用异步方式，别人做完了再通知我。大嘴听了目瞪口呆，原来饭店可以这样开，一旦拥有这种服务效率，明年利润再翻一番不是问题，后年可以赴港交所上市了。</p>
<p>总结上述几种IO模型，将其功能和特性进行对比：</p>
<p><img src="/images/java_io_model/IOtable.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/java_review_1_20190226/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/java_review_1_20190226/" itemprop="url">Java复习（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T00:00:00+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>这里<a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">博主海子的描述</a>更为详细，就不在此献丑了。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。</p>
<blockquote>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
</blockquote>
<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<p><strong>1.原子性</strong></p>
<p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>　　请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;  <span class="comment">//1</span></span><br><span class="line">y = x;   <span class="comment">//2</span></span><br><span class="line">x++;    <span class="comment">//3</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p> 　　<strong>所以上面4个语句只有语句1的操作具备原子性。</strong></p>
<p>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p><strong>2.可见性</strong></p>
<p>　　对于可见性，Java提供了<strong>volatile关键字</strong>来保证可见性。</p>
<p>　　<em>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</em></p>
<p>　　<em>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</em></p>
<p>　　另外，通过<strong>synchronized</strong>和<strong>Lock</strong>也能够保证可见性，<strong>synchronized</strong>和<strong>Lock</strong>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<p><strong>3.有序性</strong></p>
<p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>　　在Java里面，可以通过<strong>volatile</strong>关键字来保证一定的“有序性”。另外可以通过<strong>synchronized和Lock来保证有序性</strong>，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然<strong>就保证了有序性</strong>。（<strong>锁和synchronized即可以保证原子性，也可以保证可见性。</strong>都是通过保证同一时间只有一个线程执行目标代码段来实现的。）</p>
<blockquote>
<p>问：既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？<br>答：synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。</p>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>这里介绍一下volatile，一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>　　2）禁止进行指令重排序。</p>
<p>　　先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1``</span></span><br><span class="line">    <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">	stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<blockquote>
<p>　　下面解释一下这段代码为何有可能导致无法中断线程。每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>　　但是用volatile修饰之后就变得不一样了：<strong>当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</strong></p>
<p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>　　那么线程1读取到的就是最新的正确的值。</p>
</blockquote>
<p><strong>但是volatile没办法保证对变量的操作的原子性，可以部分保证有序性：</strong></p>
<blockquote>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行</p>
</blockquote>
<h2 id="volatile适用场景"><a href="#volatile适用场景" class="headerlink" title="volatile适用场景"></a>volatile适用场景</h2><p>volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean isRunning = false;</span><br><span class="line"></span><br><span class="line">public void start () &#123;</span><br><span class="line">  new Thread( () -&gt; &#123;</span><br><span class="line">    while(isRunning) &#123;</span><br><span class="line">      someOperation();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void stop () &#123;</span><br><span class="line">  isRunning = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种实现方式下，即使其它线程通过调用stop()方法将isRunning设置为false，循环也不一定会立即结束。可以通过volatile关键字，保证while循环及时得到isRunning最新的状态从而及时停止循环，结束线程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/redis_learn_1_20190226/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rookieChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog_logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RookieGuy Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/redis_learn_1_20190226/" itemprop="url">Redis学习日记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T00:00:00+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习/" itemprop="url" rel="index">
                    <span itemprop="name">学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis学习日记（一）"><a href="#Redis学习日记（一）" class="headerlink" title="Redis学习日记（一）"></a>Redis学习日记（一）</h1><p>首先，<strong>什么是redis</strong>？</p>
<p>Redis 是一个使用<code>ANSI C</code> 编写的开源、支持网络协议、基于内存、可选持久性的键值对数据库,它是一个<code>NOSQL</code>not only sql)数据库,也就是常说的非关系型数据库。</p>
<blockquote>
<p>Nosql的全称是Not Only Sql，指的是非关系型数据库，而我们常用的都是关系型数据库。就像我们常用的mysql，sqlserver一样，这些数据库一般用来存储重要信息，应对普通的业务是没有问题的。但是，随着互联网的高速发展，传统的关系型数据库在应付超大规模，超大流量以及高并发的时候力不从心。而就在这个时候，Nosql得到的高速的发展。下面是对比：</p>
<ul>
<li>存储方式：关系型数据库是表格式的，因此存储在表的行和列中。他们之间很容易关联协作存储，提取数据很方便。而Nosql数据库则与其相反，他是大块的组合在一起。通常存储在数据集中，就像文档、键值对或者图结构。</li>
<li>存储结构：关系型数据库对应的是结构化数据，数据表都预先定义了结构（列的定义），结构描述了数据的形式和内容。这一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难。而Nosql数据库基于动态结构，使用与非结构化数据。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构的变化。</li>
<li>存储扩展：这可能是两者之间最大的区别，关系型数据库是纵向扩展，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能涉及到多个表，需要通过提升计算机性能来克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限。而Nosql数据库是横向扩展的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。</li>
</ul>
</blockquote>
<h2 id="Redis-应用场景"><a href="#Redis-应用场景" class="headerlink" title="Redis 应用场景"></a>Redis 应用场景</h2><p>主要用于数据量大，并发量高的情况下</p>
<ul>
<li>数据缓存（页面具体数据），页面缓存（商品内容，新闻内容）</li>
<li>分布式集群中架构中的Session分离</li>
<li>应用排行榜，在线好友列表等</li>
<li>任务队列，例如抢购秒杀等</li>
<li>显示最新的项目列表(用户最新的回复，评论等)</li>
<li>需要负载均衡的场景（主从同步）</li>
</ul>
<blockquote>
<p>Redis在很多方面与其他数据库解决方案不同：它<strong>使用内存提供主存储支持，而仅使用硬盘做持久性的存储</strong>；它的数据模型非常独特，用的是<strong>单线程</strong>。另一个大区别在于，你可以在开发环境中使用Redis的功能，但却不需要转到Redis。</p>
<p>转向Redis当然也是可取的，许多开发者从一开始就把Redis作为首选数据库；但设想如果你的开发环境已经搭建好，应用已经在上面运行了，那么更换数据库框架显然不那么容易。另外在一些需要大容量数据集的应用，Redis也并不适合，因为它的数据集不会超过系统可用的内存。所以如果你有大数据应用，而且主要是读取访问模式，那么Redis并不是正确的选择。</p>
<p><em>你可以把它融入到你的系统中来，这就能够解决很多问题，比如那些你现有的数据库处理起来感到缓慢的任务。这些你就可以通过Redis来进行优化，或者为应用创建些新的功能。</em></p>
</blockquote>
<h2 id="Redis数据类型简介"><a href="#Redis数据类型简介" class="headerlink" title="Redis数据类型简介"></a>Redis数据类型简介</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>存储的值</th>
<th>读写能力</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串，整数或浮点数。可以包含任意数据，包括图片等二进制或者序列化的对象等。单个 <code>value</code> 的值最大上限为 <code>1G</code>字节。</td>
<td>对字符串或一部分字符串执行操作；对整数进行自增和自减操作等</td>
<td>可用于保存图片，商品序列号等。</td>
</tr>
<tr>
<td>Hash</td>
<td>包含键值对的无序散列表。等价于Java 中的 HashMap。但是在 redis 中 hash 的 key 必须是 string 类型。在 Reids 中，每个 Hash 可以存储多达 4 亿个键值对。</td>
<td>对单个 元素进行增、删、改；获取所以的键值对等</td>
<td>保存大量的对象数据</td>
</tr>
<tr>
<td>List</td>
<td>链表上的节点字符串元素。在 Redis 中的 List 类型，其内部使用的是<code>双向链表</code>实现的。</td>
<td>推入、弹出元素；修剪、查找、移除元素等</td>
<td>商品，博客，文章下面的评论列表等。</td>
</tr>
<tr>
<td>Set</td>
<td>各不相同的字符串元素。redis 中的 set 类型和 java 中的 HashSet 类似，其底层都是用HashMap 实现的，只不过所有的 value 都指向同一个对象。</td>
<td>对单个 元素进行增、删、改；计算集合 交，并补集等</td>
<td>对象属性</td>
</tr>
<tr>
<td>Sorted Set</td>
<td>带分数（权重）的有序集合</td>
<td>对单个 元素进行增、删、改；按照分数范围查元素等</td>
<td>商品销售，软件下载等各种排行榜</td>
</tr>
<tr>
<td>HyerLogLog</td>
<td>基数</td>
<td>对输入元素不进行存储，、只存储基数。</td>
<td>基数统计</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>Pub/Sub</strong>：Pub/Sub 从字面上理解就是<strong>发布（Publish）与订阅（Subscribe）</strong>，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</li>
</ul>
</blockquote>
<h2 id="主从同步（复制）"><a href="#主从同步（复制）" class="headerlink" title="主从同步（复制）"></a>主从同步（复制）</h2><p>Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态；</li>
<li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p>
<p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送SYNC命令；</li>
<li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令；</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器<strong>执行BGSAVE命令时的数据库状态</strong>。</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，<strong>从服务器执行这些写命令</strong>，将自己的数据库状态更新至主服务器数据库当前所处的状态。</li>
</ol>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>在执行完同步操作之后，主从服务器之间数据库状态已经相同了。但这个状态并非一成不变，如果主服务器执行了写操作，那么主服务器的数据库状态就会修改，并导致主从服务器状态不再一致。</p>
<p>所以为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis提供了两种持久化：<strong>快照snapshotting</strong>和<strong>AOF（append-only file）</strong>。</p>
<h3 id="快照Snapshotting"><a href="#快照Snapshotting" class="headerlink" title="快照Snapshotting"></a>快照Snapshotting</h3><p>快照持久化方法是 Redis 默认开启的持久化方法，Redis 将某一时刻的快照保存成一种称为 RDB 格式的文件中。RDB 文件是一个经过压缩的二进制文件，通过该文件，Redis 可以将内存中的数据恢复成某一时刻的状态。</p>
<p>Redis 提供了两个命令用来生成 RDB 文件，一个是 SAVE，一个是 BGSAVE。</p>
<ul>
<li>SAVE 命令会阻塞 Redis 服务器进程，走到 RDB 文件创建完毕为止，在 Redis 服务器进程阻塞期间，Redis 不能处理任何命令请求。在生产环境，我们一般不会直接使用 SAVE 命令，原因是由于它会阻塞 Redis 进程。但是，如果机器已没有足够的内存去执行 BGSAVE 命令，或者即使等待持久化操作完毕也无所谓，我们也可以使用 SAVE 命令来生成 RDB 文件。</li>
<li>BGSAVE 命令会派生出一个子进程，然后由子进程创建 RDB 文件，因此，BGSAVE 命令不会阻塞 Redis 服务器进程。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>与快照持久化通过直接保存 Redis 的键值对数据不同，AOF 持久化是通过保存 Redis 执行的写命令来记录 Redis 的内存数据。</p>
<p>理论上说，只要我们保存了所有可能修改 Redis 内存数据的命令（也就是写命令），那么根据这些保存的写命令，我们可以重新恢复 Redis 的内存状态。AOF 持久化正是利用这个原理来实现数据的持久化与数据的恢复的。 </p>
<blockquote>
<p><strong>AOF 的优点</strong></p>
<ul>
<li>AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。</li>
<li>AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</li>
<li>AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。</li>
</ul>
<p><strong>AOF 的缺点</strong></p>
<ul>
<li>对于具有相同数据的的 Redis，AOF 文件通常会比 RDB文件体积更大。</li>
<li>虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</li>
<li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。</li>
</ul>
</blockquote>
<h2 id="Redis-VS-memcache"><a href="#Redis-VS-memcache" class="headerlink" title="Redis VS. memcache"></a>Redis VS. memcache</h2><p>1、Redis和Memcache都是将数据存放在内存中。不过memcache还可用于缓存其他东西，例如图片、视频等等</p>
<p>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。 </p>
<p>3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘 . </p>
<p>4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10 </p>
<p>5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从 </p>
<p><strong>6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）,支持持久化，服务器重启，缓存依然可以获取。(这个很重要哦)</strong></p>
<p> 7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复</p>
<p> 8、Redis支持数据的备份，即master-slave模式的数据备份。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/blog_logo.jpg" alt="rookieChen">
            
              <p class="site-author-name" itemprop="name">rookieChen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rookieChen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
